<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PDF Toolkit Pro - Offline Suite</title>
    
    <!-- FONT FIX: Import Google Fonts for Type Signature -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Pacifico&family=Great+Vibes&family=Allura&display=swap" rel="stylesheet">
    
    <!-- PHASE 3: PWA Support (Single-File Approach) -->
    <meta name="theme-color" content="#6366f1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="PDF Tools">
    <link rel="manifest" href="data:application/json,%7B%22name%22%3A%22PDF%20Toolkit%20Pro%22%2C%22short_name%22%3A%22PDF%20Tools%22%2C%22description%22%3A%22Complete%20offline%20PDF%20toolkit%20-%20privacy-first%22%2C%22start_url%22%3A%22.%2F%22%2C%22scope%22%3A%22.%2F%22%2C%22display%22%3A%22standalone%22%2C%22background_color%22%3A%22%230f172a%22%2C%22theme_color%22%3A%22%236366f1%22%2C%22orientation%22%3A%22any%22%2C%22icons%22%3A%5B%7B%22src%22%3A%22data%3Aimage%2Fsvg%2Bxml%2C%253Csvg%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%20viewBox%3D%270%200%20512%20512%27%253E%253Crect%20fill%3D%27%25236366f1%27%20width%3D%27512%27%20height%3D%27512%27%20rx%3D%27100%27%2F%253E%253Cpath%20fill%3D%27white%27%20d%3D%27M150%2C100h180l70%2C70v242a20%2C20%200%200%2C1-20%2C20h-210a20%2C20%200%200%2C1-20%2C-20v-292a20%2C20%200%200%2C1%2C20%2C-20z%27%2F%253E%253Cpath%20fill%3D%27%2523e0e7ff%27%20d%3D%27M330%2C100v70h70z%27%2F%253E%253Crect%20fill%3D%27%25236366f1%27%20x%3D%27200%27%20y%3D%27220%27%20width%3D%27120%27%20height%3D%2712%27%20rx%3D%276%27%2F%253E%253Crect%20fill%3D%27%25236366f1%27%20x%3D%27200%27%20y%3D%27260%27%20width%3D%27120%27%20height%3D%2712%27%20rx%3D%276%27%2F%253E%253Crect%20fill%3D%27%25236366f1%27%20x%3D%27200%27%20y%3D%27300%27%20width%3D%2780%27%20height%3D%2712%27%20rx%3D%276%27%2F%253E%253C%2Fsvg%253E%22%2C%22sizes%22%3A%22512x512%22%2C%22type%22%3A%22image%2Fsvg%2Bxml%22%2C%22purpose%22%3A%22any%20maskable%22%7D%2C%7B%22src%22%3A%22data%3Aimage%2Fsvg%2Bxml%2C%253Csvg%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%20viewBox%3D%270%200%20192%20192%27%253E%253Crect%20fill%3D%27%25236366f1%27%20width%3D%27192%27%20height%3D%27192%27%20rx%3D%2740%27%2F%253E%253Cpath%20fill%3D%27white%27%20d%3D%27M56%2C38h68l26%2C26v91a8%2C8%200%200%2C1-8%2C8h-79a8%2C8%200%200%2C1-8%2C-8v-110a8%2C8%200%200%2C1%2C8%2C-8z%27%2F%253E%253Cpath%20fill%3D%27%2523e0e7ff%27%20d%3D%27M124%2C38v26h26z%27%2F%253E%253Crect%20fill%3D%27%25236366f1%27%20x%3D%2775%27%20y%3D%2783%27%20width%3D%2745%27%20height%3D%275%27%20rx%3D%272%27%2F%253E%253Crect%20fill%3D%27%25236366f1%27%20x%3D%2775%27%20y%3D%2798%27%20width%3D%2745%27%20height%3D%275%27%20rx%3D%272%27%2F%253E%253Crect%20fill%3D%27%25236366f1%27%20x%3D%2775%27%20y%3D%27113%27%20width%3D%2730%27%20height%3D%275%27%20rx%3D%272%27%2F%253E%253C%2Fsvg%253E%22%2C%22sizes%22%3A%22192x192%22%2C%22type%22%3A%22image%2Fsvg%2Bxml%22%2C%22purpose%22%3A%22any%22%7D%5D%7D">
    
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <style>
        /* --- ENHANCED MODERN THEME --- */
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --primary-light: #818cf8;
            --secondary: #8b5cf6;
            --danger: #ef4444;
            --success: #10b981;
            
            --bg-body: linear-gradient(135deg, #f0f9ff 0%, #f0f4ff 50%, #fef0ff 100%);
            --bg-card: #ffffff;
            --bg-panel: #f8fafc;
            --bg-hover: #f1f5f9;
            
            --text-main: #1e293b;
            --text-secondary: #475569;
            --text-muted: #64748b;
            
            --border: #e2e8f0;
            
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            
            --toast-bg: #1e293b;
            --toast-text: #fff;
            
            /* Aurora gradient colors - visible in light mode too */
            --aurora-from: rgba(99, 102, 241, 0.15);
            --aurora-via: rgba(168, 85, 247, 0.10);
            --aurora-to: rgba(236, 72, 153, 0.08);
            
            /* Phase A: Visual polish - Desktop only */
            --bg-paper-tint: rgba(255, 255, 255, 0.65);
            --bg-noise-opacity: 0.035;
            
            /* Typography scale */
            --font-xs: 0.8rem;
            --font-sm: 0.9rem;
            --font-base: 1rem;
            --font-lg: 1.15rem;
            --font-xl: 1.4rem;
            --font-2xl: 1.75rem;
            
            /* Phase D: Tool accent colors */
            --accent-sign: #8b5cf6;
            --accent-edit: #3b82f6;
            --accent-convert: #10b981;
            --accent-text: #f59e0b;
            --accent-optimize: #ec4899;
        }

        [data-theme="dark"] {
            --primary: #818cf8;
            --primary-dark: #6366f1;
            --primary-light: #a5b4fc;
            --secondary: #a78bfa;
            --danger: #f87171;
            
            /* Muted navy/blue tones instead of pure black - better eye comfort */
            --bg-body: #0a0e1a;
            --bg-card: #151b2e;
            --bg-panel: #1e2742;
            --bg-hover: #2a3656;
            
            --text-main: #e2e8f0;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            
            --border: #2a3656;
            
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.4);
            --shadow-md: 0 10px 15px -3px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
            
            --toast-bg: #f1f5f9;
            --toast-text: #0f172a;
            
            /* Aurora gradient colors - MAXIMUM visibility */
            --aurora-from: rgba(99, 102, 241, 0.50);   /* Blue - maximum visibility */
            --aurora-via: rgba(168, 85, 247, 0.35);    /* Purple - strong presence */
            --aurora-to: rgba(236, 72, 153, 0.25);     /* Pink - clearly visible */
            
            /* Noise overlay opacity */
            --bg-paper-tint: rgba(10, 14, 26, 0.6);
            --bg-noise-opacity: 0.10;  /* Increased for more texture */
            
            /* Phase D: Tool accent colors (brighter for dark mode) */
            --accent-sign: #a78bfa;
            --accent-edit: #60a5fa;
            --accent-convert: #34d399;
            --accent-text: #fbbf24;
            --accent-optimize: #f472b6;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        /* Phase E: Accessibility improvements */
        
        /* Respect reduced motion preference */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }
        
        /* Better focus outlines for keyboard navigation */
        *:focus-visible {
            outline: 3px solid var(--primary);
            outline-offset: 3px;
            border-radius: 4px;
        }
        
        /* Remove default focus outline (using :focus-visible instead) */
        *:focus:not(:focus-visible) {
            outline: none;
        }
        
        /* Skip to main content link for screen readers */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--primary);
            color: white;
            padding: 12px 20px;
            text-decoration: none;
            font-weight: 600;
            border-radius: 0 0 8px 0;
            z-index: 9999;
        }
        
        .skip-link:focus {
            top: 0;
        }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, system-ui, sans-serif;
            background: var(--bg-body); 
            padding: 20px; 
            color: var(--text-main); 
            min-height: 100vh;
            padding-bottom: 140px;
            line-height: 1.6;
            position: relative;
            
            /* PHASE 1.1: No-Slip Protection - Prevent accidental refresh on mobile */
            overscroll-behavior-y: contain;
            -webkit-overflow-scrolling: touch;
        }
        
        html {
            /* Also prevent overscroll on html element */
            overscroll-behavior-y: contain;
        }
        
        /* Aurora gradient background - DESKTOP ONLY - Maximum Visibility */
        @media (min-width: 769px) {
            body::before {
                content: "";
                position: fixed;
                inset: 0;
                pointer-events: none;
                z-index: -2;
                
                /* Aurora gradient - optimized for visibility */
                background: 
                    /* Top center - blue glow */
                    radial-gradient(
                        ellipse 120% 80% at 50% 0%,
                        var(--aurora-from),
                        transparent 75%
                    ),
                    /* Right side - purple glow */
                    radial-gradient(
                        ellipse 100% 80% at 100% 30%,
                        var(--aurora-via),
                        transparent 65%
                    ),
                    /* Left side - pink glow */
                    radial-gradient(
                        ellipse 100% 80% at 0% 30%,
                        var(--aurora-to),
                        transparent 65%
                    ),
                    /* Center ambient glow */
                    radial-gradient(
                        ellipse 60% 40% at 50% 50%,
                        rgba(99, 102, 241, 0.08),
                        transparent 70%
                    );
            }
            
            /* Noise overlay for anti-banding */
            body::after {
                content: "";
                position: fixed;
                inset: 0;
                pointer-events: none;
                z-index: -1;
                opacity: var(--bg-noise-opacity);
                
                background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            }
        }

        .container { max-width: 1280px; margin: 0 auto; position: relative; }
        
        /* HEADER */
        header { 
            text-align: center; 
            margin-bottom: 40px; 
            padding-top: 20px;
        }
        
        h1 { 
            font-size: 2.5rem; 
            font-weight: 700;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            display: inline-block;
            max-width: 100%;
        }
        
        header p { 
            color: var(--text-muted); 
            font-size: 1rem; 
            font-weight: 500;
            margin: 0;
        }
        
        .theme-toggle { 
            background: var(--bg-card); 
            border: 2px solid var(--border); 
            padding: 10px 14px; 
            border-radius: 12px;
            cursor: pointer; 
            color: var(--text-main);
            font-size: 1.2rem;
            transition: all 0.3s;
            box-shadow: var(--shadow-sm);
            z-index: 100;
            flex-shrink: 0;
        }
        
        /* PHASE 1.3: Search Bar Styles */
        .search-container {
            max-width: 600px;
            margin: 0 16px 24px 16px; /* ITEM 5: Align with tool cards */
            position: relative;
        }
        
        .search-bar {
            width: 100%;
            padding: 14px 54px 14px 58px !important;
            font-size: 1rem;
            border: 1px solid transparent;
            border-radius: 50px;
            background: var(--bg-panel);
            color: var(--text-main);
            transition: all 0.3s;
            box-shadow: none;
        }
        
        .search-bar:focus {
            outline: none;
            border-color: var(--primary);
            background: var(--bg-card);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.15);
            padding-left: 58px !important; /* Maintain same padding on focus */
        }
        
        .search-bar::placeholder {
            color: var(--text-muted);
        }
        
        .search-icon {
            position: absolute;
            left: 20px; /* ITEM 5: Icon on left side */
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.1rem; /* ITEM 5: Slightly smaller */
            color: var(--text-muted);
            opacity: 0.6; /* ITEM 5: More subtle */
            pointer-events: none;
        }
        
        .search-clear {
            position: absolute;
            right: 20px; /* ITEM 5: Clear button on right */
            top: 50%;
            transform: translateY(-50%);
            background: var(--text-muted);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 0.8rem;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .search-clear:hover {
            background: var(--danger);
            transform: translateY(-50%) scale(1.1);
        }
        
        .search-clear.visible {
            display: flex;
        }
        
        @media (max-width: 768px) {
            .search-bar {
                padding: 12px 50px 12px 54px !important; /* DOUBLE FIX: Increased to 48px for mobile */
                font-size: 0.95rem;
            }
            
            .search-container {
                margin: 20px 16px 24px 16px;
            }
            
            .search-icon {
                left: 17px; /* Slightly closer on mobile */
                font-size: 1rem;
            }
        }
        
        .theme-toggle:hover {
            transform: translateY(-50%) translateY(-2px);
            box-shadow: var(--shadow-md);
            border-color: var(--primary);
        }
        
        /* Mobile header adjustments */
        @media (max-width: 768px) {
            header {
                padding-left: 15px;
                padding-right: 15px;
                margin-bottom: 30px;
            }
            
            h1 { 
                font-size: 1.75rem;
                padding-right: 10px;
            }
            
            header p {
                font-size: 0.9rem;
            }
            
            .theme-toggle {
                padding: 9px 12px;
                font-size: 1.1rem;
                right: 0;
            }
        }
        
        @media (max-width: 480px) {
            h1 {
                font-size: 1.4rem;
            }
            
            header p {
                font-size: 0.8rem;
            }
            
            .theme-toggle {
                padding: 8px 10px;
                font-size: 1rem;
            }
        }
        
        /* Very small screens - stack vertically */
        @media (max-width: 360px) {
            header > div {
                flex-direction: column !important;
                gap: 10px;
            }
            
            .theme-toggle {
                position: static !important;
                transform: none !important;
            }
            
            h1 {
                font-size: 1.3rem;
                padding-right: 0 !important;
            }
        }

        /* TOOL CARDS */
        .tools-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); 
            gap: 20px;
            margin-bottom: 40px;
        }
        @media (max-width: 640px) { .tools-grid { grid-template-columns: 1fr; } }

        .tool-card {
            background: var(--bg-card);
            padding: 24px;
            border-radius: 16px;
            cursor: pointer;
            box-shadow: var(--shadow);
            border: 2px solid var(--border);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-align: center;
            min-height: 130px;
            position: relative;
            overflow: hidden;
        }
        .tool-card::before {
            content: '';
            position: absolute; top: 0; left: 0; right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            transform: scaleX(0);
            transition: transform 0.3s;
        }
        /* Phase B: Calmer hover on desktop */
        @media (min-width: 769px) {
            .tool-card:hover {
                transform: translateY(-2px);
                box-shadow: var(--shadow-md);
                border-color: var(--primary-light);
            }
        }
        
        /* Mobile keeps original behavior */
        @media (max-width: 768px) {
            .tool-card:hover {
                transform: translateY(-4px);
                box-shadow: var(--shadow-lg);
                border-color: var(--primary-light);
            }
        }
        
        .tool-card:hover::before { transform: scaleX(1); }
        .tool-card:active { transform: translateY(-1px); }
        .tool-card h3 { color: var(--primary); margin-bottom: 8px; font-size: 1.1rem; font-weight: 600; }
        .tool-card p { font-size: 0.875rem; color: var(--text-muted); font-weight: 500; }
        
        /* WORKSPACE */
        .workspace { 
            background: var(--bg-card);
            border-radius: 20px;
            padding: 32px;
            display: none;
            margin-bottom: 60px;
            box-shadow: var(--shadow-md);
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
        }
        
        /* Phase D: Subtle accent bar per tool category - DESKTOP ONLY */
        @media (min-width: 769px) {
            .workspace::after {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 4px;
                background: linear-gradient(90deg, var(--primary), var(--primary-light));
                opacity: 0.8;
            }
            
            /* Sign tools - Purple */
            #tool-sign::after {
                background: linear-gradient(90deg, var(--accent-sign), #a78bfa);
            }
            
            /* Edit tools - Blue */
            #tool-merge::after,
            #tool-split::after,
            #tool-rotate::after,
            #tool-delete::after,
            #tool-watermark::after {
                background: linear-gradient(90deg, var(--accent-edit), #60a5fa);
            }
            
            /* Convert tools - Green */
            #tool-images::after {
                background: linear-gradient(90deg, var(--accent-convert), #34d399);
            }
            
            /* Text tools - Orange */
            #tool-extract-text::after,
            #tool-ocr::after,
            #tool-text-pdf::after {
                background: linear-gradient(90deg, var(--accent-text), #fbbf24);
            }
            
            /* Optimize tools - Pink */
            #tool-compress::after,
            #tool-numbers::after,
            #tool-metadata::after {
                background: linear-gradient(90deg, var(--accent-optimize), #f472b6);
            }
        }
        
        .workspace.active { display: block; animation: fadeInUp 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .workspace h2 { font-size: 1.75rem; font-weight: 700; color: var(--text-main); margin-bottom: 24px; }
        .workspace h3 { font-size: 1.3rem; font-weight: 600; color: var(--text-main); margin-bottom: 16px; }

        .back-btn { 
            background: var(--bg-panel); border: 1px solid var(--border); color: var(--text-secondary);
            cursor: pointer; font-weight: 600; margin-bottom: 20px;
            display: inline-flex; align-items: center; gap: 8px;
            font-size: 0.95rem; padding: 10px 16px; border-radius: 12px;
            transition: all 0.2s;
        }
        .back-btn:hover {
            background: var(--bg-hover); border-color: var(--primary);
            color: var(--primary); transform: translateX(-2px);
        }

        /* SPLIT LAYOUT */
        .split-layout { display: flex; flex-direction: column; gap: 24px; }
        .control-panel { background: var(--bg-panel); padding: 20px; border-radius: 16px; border: 1px solid var(--border); order: 1; }
        .visual-panel { order: 2; }
        @media (min-width: 900px) { 
            .split-layout { display: grid; grid-template-columns: 360px 1fr; gap: 28px; }
            .control-panel { position: sticky; top: 20px; height: fit-content; order: unset; }
            .visual-panel { order: unset; }
        }

        /* PREVIEW GRID */
        .preview-grid { 
            display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 16px; max-height: 65vh; overflow-y: auto; padding: 8px;
            border: 1px solid var(--border); border-radius: 16px; background: var(--bg-panel);
        }
        
        @media (max-width: 640px) {
            .preview-grid {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
                gap: 12px;
            }
        }
        
        .page-card { 
            border: 2px solid var(--border); border-radius: 12px; overflow: hidden;
            background: var(--bg-card); position: relative; min-height: 160px;
            display: flex; flex-direction: column; transition: all 0.2s; cursor: pointer;
        }
        .page-card:hover { border-color: var(--primary-light); box-shadow: var(--shadow); transform: translateY(-2px); }
        .page-card.selected { border-color: var(--primary); box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1); }
        .page-canvas { width: 100%; display: block; flex: 1; }
        .page-footer { 
            padding: 10px; background: var(--bg-panel); border-top: 1px solid var(--border);
            display: flex; justify-content: center; align-items: center; gap: 12px;
            font-size: 0.875rem; font-weight: 600; color: var(--text-secondary);
        }
        
        /* Mobile - larger touch targets */
        @media (max-width: 640px) {
            .page-footer {
                padding: 12px 8px;
                gap: 8px;
            }
            .icon-btn {
                min-width: 36px !important;
                min-height: 36px !important;
                padding: 6px !important;
                display: inline-flex !important;
                align-items: center !important;
                justify-content: center !important;
            }
        }
            display: flex; justify-content: center; align-items: center; gap: 12px;
            font-size: 0.875rem; font-weight: 600; color: var(--text-secondary);
        }
        
        /* SIGNATURE */
        .sign-area-wrapper { 
            position: relative; background: linear-gradient(135deg, #64748b 0%, #475569 100%);
            margin-bottom: 24px; overflow: auto; max-height: 70vh;
            border: 2px solid var(--border); border-radius: 16px;
            text-align: center; padding: 24px; box-shadow: var(--shadow-md);
        }
        .pdf-page-container { 
            position: relative; display: inline-block; margin-bottom: 24px;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25);
            background: white; cursor: crosshair; border-radius: 4px; overflow: hidden;
            transition: all 0.2s;
        }
        .pdf-page-container canvas { display: block; width: 100%; height: auto; }
        .pdf-page-container.drag-over {
            box-shadow: 0 0 0 4px var(--primary), 0 25px 50px -12px rgba(0,0,0,0.25);
            transform: scale(1.01);
        }
        
        .placed-sig {
            position: absolute; border: 2px dashed transparent; cursor: grab;
            z-index: 100; width: 150px; touch-action: none; transition: all 0.2s;
            border-radius: 8px;
        }
        .placed-sig:hover { 
            border-color: var(--primary-light); 
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
        }
        .placed-sig.selected { 
            border: 3px solid var(--primary); background: rgba(99, 102, 241, 0.08);
            box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.15);
        }
        .placed-sig img { width: 100%; height: 100%; pointer-events: none; display: block; }
        
        /* Close button on placed signatures */
        .sig-close-btn {
            position: absolute;
            top: -12px;
            right: -12px;
            width: 36px;
            height: 36px;
            background: var(--danger);
            color: white;
            border: 3px solid white;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            line-height: 1;
            z-index: 101;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Always show close button on touch devices */
        @media (hover: none) and (pointer: coarse) {
            .sig-close-btn {
                display: flex;
                width: 40px;
                height: 40px;
                top: -14px;
                right: -14px;
            }
        }
        
        /* Show on hover for desktop */
        @media (hover: hover) and (pointer: fine) {
            .placed-sig:hover .sig-close-btn,
            .placed-sig.selected .sig-close-btn {
                display: flex;
            }
        }
        
        .sig-close-btn:hover {
            transform: scale(1.15);
            background: #dc2626;
            box-shadow: 0 6px 16px rgba(239, 68, 68, 0.5);
        }
        
        .sig-close-btn:active {
            transform: scale(1.05);
        }
        
        /* Better touch targets for placed signatures */
        .placed-sig {
            position: absolute; 
            border: 2px dashed transparent; 
            cursor: grab;
            z-index: 100; 
            width: 150px; 
            touch-action: none; 
            transition: all 0.2s;
            border-radius: 8px;
            min-width: 80px;
            min-height: 40px;
        }
        
        /* Larger minimum size on mobile */
        @media (hover: none) and (pointer: coarse) {
            .placed-sig {
                min-width: 100px;
                min-height: 50px;
                border-width: 3px;
            }
        }
        
        /* Signature Panel Styling */
        .signature-panel {
            background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-panel) 100%);
            border: 2px solid var(--border);
            border-radius: 16px;
            padding: 24px;
            height: fit-content;
            position: sticky;
            top: 20px;
            box-shadow: var(--shadow-lg);
        }
        
        .signature-panel h4 {
            margin-bottom: 12px;
            color: var(--text-main);
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .signature-panel h4::before {
            content: 'âœï¸';
            font-size: 1.3rem;
        }
        
        #signature-stamp {
            background: white;
            border: 3px dashed var(--primary);
            border-radius: 16px;
            padding: 24px;
            text-align: center;
            cursor: grab;
            user-select: none;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Larger touch area on mobile */
        @media (hover: none) and (pointer: coarse) {
            #signature-stamp {
                padding: 32px;
                min-height: 140px;
                border-width: 4px;
            }
        }
        
        #signature-stamp::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(99,102,241,0.1), transparent);
            transition: left 0.6s;
        }
        
        /* Phase B: Calmer signature stamp hover - desktop only */
        @media (min-width: 769px) {
            #signature-stamp:hover {
                border-color: var(--primary-dark);
                transform: translateY(-2px);
                box-shadow: 0 6px 16px rgba(99, 102, 241, 0.25);
            }
        }
        
        @media (max-width: 768px) {
            #signature-stamp:hover {
                border-color: var(--primary-dark);
                transform: translateY(-4px);
                box-shadow: 0 8px 20px rgba(99, 102, 241, 0.3);
            }
        }
        
        #signature-stamp:hover::before {
            left: 100%;
        }
        
        #signature-stamp:active {
            cursor: grabbing;
            transform: translateY(-2px) scale(0.98);
        }
        
        .drag-instruction {
            background: rgba(99, 102, 241, 0.1);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 0.85rem;
            color: var(--primary-dark);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            animation: pulse 2s infinite;
            font-weight: 600;
            text-align: center;
        }
        
        /* More prominent on mobile */
        @media (hover: none) and (pointer: coarse) {
            .drag-instruction {
                padding: 12px 16px;
                font-size: 0.9rem;
                border-width: 2px;
            }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.85; transform: scale(0.98); }
        }
        
        /* Phase B: Calmer pulse on desktop */
        @media (min-width: 769px) {
            @keyframes pulse {
                0%, 100% { opacity: 1; transform: scale(1); }
                50% { opacity: 0.92; transform: scale(0.99); }
            }
        }
        
        .drag-instruction::before {
            content: 'ğŸ‘†';
            font-size: 1.4rem;
        }
        
        @media (hover: none) and (pointer: coarse) {
            .drag-instruction::before {
                font-size: 1.6rem;
            }
        }
        
        .signature-tab {
            transition: all 0.3s;
        }
        
        .signature-tab:hover {
            background: var(--bg-hover);
            border-radius: 8px 8px 0 0;
        }
        
        #sig-toolbar {
            position: fixed; bottom: 0; left: 0; right: 0;
            background: var(--bg-card); border-top: 2px solid var(--border);
            padding: 20px; display: none; align-items: center; justify-content: space-between;
            box-shadow: 0 -10px 30px -5px rgba(0,0,0,0.15); z-index: 3000; gap: 20px;
            backdrop-filter: blur(10px);
        }
        #sig-toolbar.active { display: flex; }
        .toolbar-group { display: flex; align-items: center; gap: 12px; flex: 1; }
        .drawing-box { 
            border: 2px solid var(--border); border-radius: 16px; background: #fff;
            touch-action: none; margin-bottom: 16px; position: relative;
            height: 220px; width: 100%; cursor: crosshair; box-shadow: var(--shadow-sm);
        }
        
        /* PHASE 2.5: Signature Panel Mobile Optimization */
        @media (max-width: 768px) {
            .drawing-box {
                height: 250px; /* Taller for easier drawing on mobile */
                border-width: 3px; /* Thicker border for better visibility */
            }
            
            .drawing-box canvas {
                width: 100% !important;
                height: 100% !important;
            }
            
            /* Signature stamp - larger on mobile */
            #signature-stamp {
                max-width: 220px !important;
                max-height: 110px !important;
            }
            
            /* Bottom signature toolbar - make sticky on mobile */
            #sig-toolbar {
                position: fixed !important;
                bottom: 0 !important;
                left: 0 !important;
                right: 0 !important;
                padding-bottom: calc(12px + env(safe-area-inset-bottom)) !important;
                box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.15) !important;
                z-index: 999 !important;
                border-radius: 0 !important;
            }
            
            /* Increase close button size on signatures */
            .sig-close-btn {
                width: 40px !important;
                height: 40px !important;
                font-size: 1.8rem !important;
            }
        }

        /* TEXT LAYERS */
        .text-layer-wrapper { position: relative; margin-bottom: 20px; border: 1px solid var(--border); background: white; display: inline-block; overflow: hidden; line-height: 1; }
        .textLayer { position: absolute; inset: 0; overflow: hidden; opacity: 0.25; line-height: 1.0; z-index: 10; }
        .textLayer > span { color: transparent; position: absolute; white-space: pre; cursor: text; transform-origin: 0% 0%; }
        ::selection { background: rgba(99, 102, 241, 0.2); color: var(--text-main); }

        /* UPLOAD AREA */
        .upload-area { 
            border: 3px dashed var(--border); border-radius: 16px;
            padding: 48px 32px; text-align: center; cursor: pointer;
            background: var(--bg-panel); margin-bottom: 24px;
            transition: all 0.3s; position: relative;
        }
        .upload-area:hover {
            border-color: var(--primary); background: var(--bg-card);
            transform: translateY(-2px); box-shadow: var(--shadow-md);
        }
        .upload-area p { font-size: 1.05rem; color: var(--text-secondary); font-weight: 600; }
        
        /* BUTTONS */
        .btn { 
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white; border: none; padding: 14px 28px; border-radius: 12px;
            cursor: pointer; font-weight: 600; font-size: 1rem;
            transition: all 0.3s; box-shadow: var(--shadow);
        }
        
        /* Phase B: Calmer button hover - desktop only */
        @media (min-width: 769px) {
            .btn:hover { 
                transform: translateY(-2px); 
                box-shadow: var(--shadow-md); 
            }
        }
        
        @media (max-width: 768px) {
            .btn:hover { 
                transform: translateY(-2px); 
                box-shadow: var(--shadow-lg); 
            }
        }
        
        .btn:active { transform: translateY(0); }
        .btn-danger { background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%); }
        /* Phase E: Better disabled state contrast */
        .btn:disabled { 
            background: var(--bg-panel); 
            color: var(--text-muted);
            opacity: 0.7; 
            cursor: not-allowed;
            border: 2px solid var(--border);
        }
        .btn:disabled:hover { transform: none; box-shadow: none; }
        .btn-outline { 
            background: var(--bg-card); border: 2px solid var(--border); color: var(--text-main);
            margin-bottom: 12px; padding: 12px 20px; border-radius: 12px;
            width: 100%; font-weight: 600; transition: all 0.2s;
        }
        .btn-outline:hover { border-color: var(--primary); color: var(--primary); background: var(--bg-hover); }
        
        /* PHASE 2: Mobile Touch Target & Bottom Action Bar Improvements */
        @media (max-width: 768px) {
            /* Phase 2.1: Larger Touch Targets (48px minimum - Apple/Google standard) */
            .btn, .btn-outline {
                min-height: 48px;
                padding: 14px 24px;
                font-size: 1rem;
            }
            
            .icon-btn {
                min-width: 48px;
                min-height: 48px;
                font-size: 1.3rem;
            }
            
            .tool-card {
                min-height: 90px;
                padding: 20px;
            }
            
            input[type="radio"],
            input[type="checkbox"] {
                width: 24px;
                height: 24px;
                min-width: 24px;
                min-height: 24px;
            }
            
            /* Phase 2.2: Bottom Action Bar - Sticky footer for primary actions */
            .mobile-action-bar {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background: var(--bg-card);
                border-top: 2px solid var(--border);
                padding: 12px 16px;
                padding-bottom: calc(12px + env(safe-area-inset-bottom));
                box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.1);
                z-index: 1000;
                display: flex;
                gap: 10px;
                backdrop-filter: blur(10px);
            }
            
            .mobile-action-bar .btn {
                flex: 1;
                margin: 0;
                white-space: nowrap;
            }
            
            /* Add padding to body when action bar is present */
            body.has-action-bar {
                padding-bottom: 90px;
            }
            
            /* Phase 2.3: Better Upload Areas */
            .upload-area {
                min-height: 140px;
                padding: 24px 20px;
                font-size: 1.1rem;
                border: 3px dashed var(--primary);
                cursor: pointer;
            }
            
            .upload-area::before {
                content: 'ğŸ‘†';
                display: block;
                font-size: 2.5rem;
                margin-bottom: 12px;
            }
            
            .upload-area p {
                margin: 0;
            }
            
            .upload-area p::after {
                content: ' (Tap to Select)';
                display: block;
                font-size: 0.85rem;
                color: var(--text-muted);
                margin-top: 6px;
                font-weight: normal;
            }
        }
        
        /* INPUTS */
        select, input[type=text], input[type=range], input[type=color] { 
            width: 100%; padding: 12px 16px; border-radius: 12px;
            border: 2px solid var(--border); margin-bottom: 16px;
            background: var(--bg-card); color: var(--text-main);
            font-size: 1rem; transition: all 0.2s; font-family: inherit;
        }
        select:focus, input[type=text]:focus {
            outline: none; border-color: var(--primary);
            box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1);
        }
        input[type=color] { height: 56px; padding: 6px; cursor: pointer; }
        input[type=range] {
            padding: 0; height: 8px; background: var(--border);
            border: none; border-radius: 4px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 20px; height: 20px;
            border-radius: 50%; background: var(--primary);
            cursor: pointer; box-shadow: var(--shadow); transition: all 0.2s;
        }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.1); }
        textarea { 
            width: 100%; height: 320px; padding: 16px; border-radius: 16px;
            border: 2px solid var(--border); background: var(--bg-card);
            color: var(--text-main); 
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
            resize: vertical; font-size: 0.95rem; line-height: 1.7; transition: all 0.3s;
        }
        
        /* Phase E: Better placeholder contrast */
        textarea::placeholder,
        input::placeholder {
            color: var(--text-muted);
            opacity: 0.7;
        }
        
        textarea:focus { 
            outline: none; 
            border-color: var(--primary); 
            box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1); 
        }
        
        /* Phase C: Enhanced focus mode for text tools - DESKTOP ONLY */
        @media (min-width: 769px) {
            textarea:focus {
                line-height: 1.85;
                background: var(--bg-card);
                box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.15), 0 8px 24px rgba(0, 0, 0, 0.08);
                transform: translateY(-2px);
            }
            
            /* Dim workspace when textarea is focused */
            #tool-extract-text:has(textarea:focus) .workspace > *:not(textarea):not(.btn),
            #tool-ocr:has(textarea:focus) .workspace > *:not(textarea):not(.btn):not(#ocr-editor),
            #tool-text-pdf:has(textarea:focus) .workspace > *:not(textarea):not(.btn) {
                opacity: 0.6;
                transition: opacity 0.3s;
            }
            
            /* Keep buttons visible */
            #tool-extract-text:has(textarea:focus) .btn,
            #tool-ocr:has(textarea:focus) .btn,
            #tool-text-pdf:has(textarea:focus) .btn {
                opacity: 1;
            }
            
            /* Subtle focus mode indicator */
            #tool-extract-text:has(textarea:focus)::before,
            #tool-ocr:has(textarea:focus)::before,
            #tool-text-pdf:has(textarea:focus)::before {
                content: "ğŸ“– Focus Mode";
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(99, 102, 241, 0.95);
                color: white;
                padding: 8px 16px;
                border-radius: 20px;
                font-size: 0.85rem;
                font-weight: 600;
                z-index: 1000;
                box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
                animation: fadeInFocus 0.3s;
            }
            
            @keyframes fadeInFocus {
                from { opacity: 0; transform: translateY(-10px); }
                to { opacity: 1; transform: translateY(0); }
            }
            
            /* Better readability in text tools */
            #tool-extract-text textarea,
            #tool-ocr textarea,
            #tool-text-pdf textarea {
                font-size: 1rem;
                padding: 20px;
            }
        }
        
        .slider-label { display: flex; justify-content: space-between; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem; font-weight: 600; }
        label { display: block; margin-bottom: 8px; color: var(--text-secondary); font-weight: 600; font-size: 0.95rem; }

        /* MERGE LIST */
        .file-item { 
            background: var(--bg-panel); padding: 14px 16px; margin-bottom: 10px;
            border-radius: 12px; display: flex; justify-content: space-between; align-items: center;
            border: 2px solid var(--border); cursor: grab; transition: all 0.2s;
        }
        .file-item:hover { border-color: var(--primary-light); box-shadow: var(--shadow); transform: translateX(4px); }
        .file-item.dragging { opacity: 0.5; border-color: var(--primary); }
        .icon-btn { 
            font-size: 1.3rem; padding: 6px 10px; background: none; border: none;
            cursor: pointer; color: var(--text-main); transition: all 0.2s; border-radius: 8px;
        }
        .icon-btn:hover { background: var(--bg-hover); transform: scale(1.1); }
        .result-item { 
            background: var(--bg-panel); padding: 16px; margin-bottom: 12px;
            border-radius: 12px; display: flex; justify-content: space-between; align-items: center;
            border: 1px solid var(--border); box-shadow: var(--shadow-sm);
        }

        /* TOAST & LOADER */
        #toast { 
            visibility: hidden; min-width: 280px; background-color: var(--toast-bg);
            color: var(--toast-text); text-align: center; border-radius: 50px;
            padding: 16px 24px; position: fixed; z-index: 4000;
            left: 50%; bottom: 100px; transform: translateX(-50%) translateY(50px);
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25);
            font-weight: 600; opacity: 0; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #toast.show { 
            visibility: visible; 
            opacity: 1; 
            bottom: 120px;
            transform: translateX(-50%) translateY(0);
            animation: toastSlideIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        @keyframes toastSlideIn {
            0% {
                transform: translateX(-50%) translateY(40px);
                opacity: 0;
            }
            100% {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }
        
        /* PHASE 2.4: Toast Repositioning for Mobile */
        @media (max-width: 768px) {
            #toast {
                bottom: 90px; /* Move higher to avoid bottom action bar */
                min-width: 250px;
                max-width: 90%;
                padding: 14px 20px;
                font-size: 0.95rem;
            }
            
            #toast.show {
                bottom: 110px; /* Adjusted for animation */
            }
        }
        
        /* FORCE TRANSPARENT OVERLAY - Global Loader */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* LOADER - FORCED TRANSPARENT OVERLAY (Nuclear Fix) */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .loader { 
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            /* CRITICAL: Semi-transparent background (40% opacity) */
            background: rgba(0, 0, 0, 0.40) !important;
            background-color: rgba(0, 0, 0, 0.40) !important;
            /* Blur effect for modern browsers */
            backdrop-filter: blur(6px) !important;
            -webkit-backdrop-filter: blur(6px) !important; /* Safari */
            -moz-backdrop-filter: blur(6px) !important;    /* Firefox */
            /* Layout */
            display: none;
            justify-content: center !important;
            align-items: center !important;
            flex-direction: column !important;
            /* Stacking */
            z-index: 5000 !important;
            /* Text color */
            color: white !important;
            /* Prevent pointer events on background */
            pointer-events: auto !important;
        }
        
        .loader[style*="display: flex"], 
        .loader[style*="display:flex"] {
            display: flex !important;
        }
        .spinner { 
            width: 56px; height: 56px; border: 4px solid rgba(255,255,255,0.2);
            border-top-color: var(--primary); border-radius: 50%;
            animation: spin 0.8s linear infinite; margin-bottom: 24px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #progress-bar { width: 80%; max-width: 320px; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; }
        #progress-fill { width: 0%; height: 100%; background: linear-gradient(90deg, var(--primary), var(--secondary)); transition: width 0.3s; border-radius: 4px; }
        
        /* SCROLLBAR */
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: var(--bg-panel); border-radius: 5px; }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }
        
        /* RESPONSIVE */
        @media (max-width: 640px) {
            .workspace { padding: 20px; }
            .control-panel { padding: 16px; }
            .btn { padding: 12px 20px; font-size: 0.95rem; }
            .tools-grid { gap: 15px; }
        }
        
        /* ============================================ */
        /* MOBILE REVAMP - LEVEL 2 */
        /* Only affects screens < 768px */
        /* ============================================ */
        
        @media (max-width: 768px) {
            /* PHASE 1: TYPOGRAPHY & SPACING */
            
            /* Base font size - no text smaller than 16px */
            body {
                font-size: 16px;
                line-height: 1.6;
            }
            
            /* Better spacing throughout */
            .container {
                padding: 16px;
            }
            
            .workspace {
                padding: 24px 16px;
                margin-bottom: 20px;
            }
            
            /* PHASE 2: TOOL CARDS - BIGGER & CLEANER */
            
            .tools-grid {
                grid-template-columns: 1fr;
                gap: 16px;
            }
            
            .tool-card {
                min-height: 120px;
                padding: 24px 20px;
                border-radius: 20px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            }
            
            .tool-card h3 {
                font-size: 1.35rem;
                margin-bottom: 6px;
                display: flex;
                align-items: center;
                gap: 10px;
            }
            
            .tool-card h3::before {
                content: attr(data-emoji);
                font-size: 2rem;
            }
            
            .tool-card p {
                font-size: 0.95rem;
                opacity: 0.8;
                margin: 0;
            }
            
            /* Active tap state */
            .tool-card:active {
                transform: scale(0.98);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
            }
            
            /* BUTTONS - FULL WIDTH & LARGER */
            
            .btn {
                width: 100%;
                padding: 16px 24px;
                font-size: 1rem;
                font-weight: 600;
                min-height: 52px;
                border-radius: 14px;
                box-shadow: 0 4px 12px rgba(99, 102, 241, 0.2);
            }
            
            .btn:active {
                transform: translateY(0px);
            }
            
            .btn, .btn-outline, .icon-btn, .preset-btn {
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }
        
        /* Button press feedback - tactile feel */
        .btn:active, .btn-outline:active, .preset-btn:active {
            transform: scale(0.97) translateY(1px);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        
        .icon-btn:active {
            transform: scale(0.92);
        }
        
        /* Touch device optimization */
        @media (hover: none) and (pointer: coarse) {
            .btn:active, .btn-outline:active {
                transform: scale(0.95) translateY(2px);
            }
        }
        
        .btn-outline {
                width: 100%;
                padding: 14px 24px;
                font-size: 0.95rem;
                min-height: 48px;
                border-radius: 12px;
            }
            
            /* Button groups - stack vertically */
            .workspace > div:has(.btn, .btn-outline) {
                display: flex;
                flex-direction: column;
                gap: 12px;
            }
            
            /* Back button - larger touch target */
            .back-btn {
                padding: 12px 20px;
                font-size: 1rem;
                min-height: 44px;
                margin-bottom: 20px;
            }
            
            /* UPLOAD AREAS - MORE VISUAL */
            
            .upload-area {
                min-height: 160px;
                padding: 32px 24px;
                border-radius: 20px;
                border-width: 3px;
                margin-bottom: 24px;
                background: linear-gradient(135deg, rgba(99, 102, 241, 0.03) 0%, rgba(139, 92, 246, 0.03) 100%);
            }
            
            .upload-area p {
                font-size: 1.1rem;
                font-weight: 600;
                margin: 8px 0 0 0;
            }
            
            .upload-area:active {
                transform: scale(0.98);
                border-color: var(--primary);
            }
            
            /* Add emoji to upload areas */
            .upload-area::before {
                content: 'ğŸ“¤';
                font-size: 3rem;
                display: block;
                margin-bottom: 12px;
            }
            
            /* FORM CONTROLS - LARGER & CLEARER */
            
            input[type="text"],
            input[type="email"],
            input[type="number"],
            textarea,
            select {
                min-height: 48px;
                padding: 12px 16px;
                font-size: 16px;
                border-radius: 12px;
                border: 2px solid var(--border);
            }
            
            textarea {
                min-height: 120px;
                padding: 14px 16px;
            }
            
            /* Color pickers - larger touch target */
            input[type="color"] {
                width: 80px;
                height: 48px;
                border-radius: 10px;
                cursor: pointer;
            }
            
            /* Range sliders - bigger thumb */
            input[type="range"] {
                height: 40px;
                margin: 8px 0;
            }
            
            input[type="range"]::-webkit-slider-thumb {
                width: 24px;
                height: 24px;
            }
            
            input[type="range"]::-moz-range-thumb {
                width: 24px;
                height: 24px;
            }
            
            /* WORKSPACE HEADERS */
            
            .workspace h2 {
                font-size: 1.75rem;
                margin-bottom: 20px;
                padding-bottom: 16px;
                border-bottom: 2px solid var(--border);
                position: sticky;
                top: 0;
                background: var(--bg-main);
                z-index: 10;
                margin-top: -24px;
                padding-top: 24px;
            }
            
            /* CONTROL PANELS - BETTER SPACING */
            
            .control-panel {
                padding: 20px 16px;
                border-radius: 16px;
                margin-bottom: 20px;
            }
            
            /* ICON BUTTONS - LARGER TOUCH TARGETS */
            
            .icon-btn {
                min-width: 44px;
                min-height: 44px;
                padding: 10px;
                font-size: 1.1rem;
                border-radius: 10px;
            }
            
            /* PREVIEW GRIDS - BETTER MOBILE LAYOUT */
            
            .preview-grid {
                grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
                gap: 14px;
                padding: 12px;
            }
            
            .page-card {
                border-radius: 14px;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            }
            
            /* PAGE FOOTER - LARGER BUTTONS */
            
            .page-footer {
                padding: 14px 10px;
                gap: 10px;
            }
            
            .page-footer button {
                min-width: 40px;
                min-height: 40px;
            }
            
            /* TOAST NOTIFICATIONS */
            
            #toast {
                bottom: 24px;
                font-size: 1rem;
                padding: 16px 24px;
                border-radius: 12px;
                max-width: 90%;
                left: 50%;
                transform: translateX(-50%);
            }
            
            #toast.show {
                bottom: 24px;
            }
            
            /* SIGNATURE TOOLBAR - BETTER MOBILE */
            
            #sig-toolbar {
                padding: 16px;
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }
            
            #sig-toolbar .btn {
                width: 100%;
                margin: 0;
            }
            
            .toolbar-group {
                flex-direction: column;
                gap: 10px;
            }
            
            /* SIGNATURE PANEL - MOBILE OPTIMIZED */
            
            .signature-panel {
                padding: 20px 16px;
                border-radius: 16px;
            }
            
            #signature-stamp {
                padding: 28px;
                border-radius: 14px;
                min-height: 120px;
            }
            
            .drag-instruction {
                padding: 12px 16px;
                font-size: 0.95rem;
                border-radius: 10px;
            }
            
            /* DRAWING BOX */
            
            .drawing-box {
                height: 200px;
                border-radius: 14px;
                margin-bottom: 16px;
            }
            
            /* SPLIT LAYOUTS - STACK ON MOBILE */
            
            .split-layout {
                display: flex;
                flex-direction: column;
                gap: 20px;
            }
            
            /* TWO-COLUMN LAYOUTS - STACK */
            
            [style*="display:grid"][style*="grid-template-columns"] {
                display: flex !important;
                flex-direction: column !important;
            }
            
            /* FLOATING ACTION BUTTON FOR PRIMARY ACTIONS */
            
            .workspace .btn:last-of-type {
                position: sticky;
                bottom: 16px;
                z-index: 100;
                box-shadow: 0 8px 24px rgba(99, 102, 241, 0.3);
                margin-top: 24px;
            }
            
            /* BETTER FOCUS STATES WITH PULSE GLOW */
            
            input:focus,
            textarea:focus,
            select:focus,
            button:focus {
                outline: none;
                box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.2);
                animation: focusPulse 0.4s ease-out;
            }
            
            @keyframes focusPulse {
                0% { 
                    box-shadow: 0 0 0 0 rgba(99, 102, 241, 0); 
                }
                50% { 
                    box-shadow: 0 0 0 6px rgba(99, 102, 241, 0.3); 
                }
                100% { 
                    box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.2); 
                }
            }
            
            /* LOADING SPINNER - LARGER ON MOBILE */
            
            .spinner {
                width: 64px;
                height: 64px;
                border-width: 5px;
            }
            
            #loader-text {
                font-size: 1.05rem;
                margin-top: 8px;
            }
            
            /* PROGRESS BAR */
            
            #progress-bar {
                width: 90%;
                height: 10px;
                border-radius: 5px;
            }
        }
        
        /* SMALL PHONES - EXTRA ADJUSTMENTS */
        @media (max-width: 480px) {
            .tool-card h3 {
                font-size: 1.2rem;
            }
            
            .preview-grid {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
                gap: 12px;
            }
            
            .workspace h2 {
                font-size: 1.5rem;
            }
        }
        
        /* COLLAPSIBLE SECTIONS & STEP INDICATORS - MOBILE ONLY */
        @media (max-width: 768px) {
            .collapsible-section {
                border: 2px solid var(--border);
                border-radius: 14px;
                margin-bottom: 16px;
                overflow: hidden;
                background: var(--bg-card);
            }
            
            .collapsible-header {
                padding: 16px 20px;
                background: var(--bg-panel);
                cursor: pointer;
                display: flex;
                justify-content: space-between;
                align-items: center;
                font-weight: 600;
                font-size: 1.05rem;
                user-select: none;
                -webkit-tap-highlight-color: transparent;
            }
            
            .collapsible-header:active {
                background: var(--bg-hover);
            }
            
            .collapsible-header::after {
                content: 'â–¼';
                transition: transform 0.3s;
                font-size: 0.8rem;
                color: var(--text-muted);
            }
            
            .collapsible-header.collapsed::after {
                transform: rotate(-90deg);
            }
            
            .collapsible-content {
                padding: 20px;
                max-height: 1000px;
                overflow: hidden;
                transition: max-height 0.3s ease, padding 0.3s ease;
            }
            
            .collapsible-content.collapsed {
                max-height: 0;
                padding: 0 20px;
            }
            
            /* STEP INDICATORS */
            
            .step-indicator {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 24px;
                padding: 0 10px;
            }
            
            .step {
                flex: 1;
                display: flex;
                flex-direction: column;
                align-items: center;
                position: relative;
            }
            
            .step-number {
                width: 36px;
                height: 36px;
                border-radius: 50%;
                background: var(--bg-panel);
                border: 2px solid var(--border);
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: 600;
                font-size: 0.9rem;
                margin-bottom: 6px;
                z-index: 2;
            }
            
            .step.active .step-number {
                background: var(--primary);
                border-color: var(--primary);
                color: white;
            }
            
            .step.completed .step-number {
                background: #10b981;
                border-color: #10b981;
                color: white;
            }
            
            .step.completed .step-number::before {
                content: 'âœ“';
            }
            
            .step-label {
                font-size: 0.75rem;
                color: var(--text-muted);
                text-align: center;
            }
            
            .step.active .step-label {
                color: var(--primary);
                font-weight: 600;
            }
            
            .step-connector {
                position: absolute;
                top: 18px;
                left: 50%;
                width: 100%;
                height: 2px;
                background: var(--border);
                z-index: 1;
            }
            
            .step.completed .step-connector {
                background: #10b981;
            }
            
            .step:last-child .step-connector {
                display: none;
            }
        }
        
        /* COMPRESSION OPTIONS */
        .compression-option {
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        
        .compression-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .compression-option:active {
            transform: translateY(0);
        }
        
        .compression-mode {
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        
        .compression-mode:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .compression-mode:active {
            transform: translateY(0);
        }
        
        /* IMAGE OPTIMIZER PRESETS */
        .preset-btn {
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            border: 2px solid var(--border);
            background: var(--bg-card);
        }
        
        .preset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-color: var(--primary) !important;
        }
        
        .preset-btn:active {
            transform: translateY(0);
        }
        
        .preset-btn.selected {
            border-color: var(--primary) !important;
            background: rgba(99, 102, 241, 0.1) !important;
        }
        
        .preset-btn.selected .preset-title {
            color: var(--primary) !important;
        }
        
        /* Compression Level Radio Labels */
        input[type="radio"]:checked + div > div:first-child {
            color: var(--primary);
        }
        
        /* DELETED: Conflicting CSS rule removed - JavaScript now handles radio button styling */
        
        @media (max-width: 768px) {
            .compression-option {
                padding: 14px 12px !important;
            }
            
            .compression-mode {
                padding: 14px !important;
            }
            
            #compress-controls [style*="grid-template-columns"] {
                grid-template-columns: 1fr !important;
                gap: 12px !important;
            }
            
            /* Image Optimizer Mobile */
            .preset-btn {
                padding: 14px 10px !important;
            }
            
            #comp-editor [style*="grid-template-columns: repeat(3, 1fr)"] {
                grid-template-columns: 1fr !important;
                gap: 10px !important;
            }
            
            /* Image Optimizer Modal Styles */
            #img-optimizer-upload-modal button:hover {
                background: var(--bg-hover) !important;
                border-color: var(--primary) !important;
            }
            
            #img-optimizer-upload-modal button:active {
                transform: scale(0.98);
            }
            
            /* OCR Modal Styles */
            #ocr-upload-modal button:hover {
                background: var(--bg-hover) !important;
                border-color: var(--primary) !important;
            }
            
            #ocr-upload-modal button:active {
                transform: scale(0.98);
            }
        }
        
        /* Mobile-optimized layouts */
        @media (max-width: 768px) {
            /* Split layout becomes single column on mobile */
            .split-layout {
                grid-template-columns: 1fr !important;
                gap: 20px !important;
            }
            
            /* Control panels full width */
            .control-panel, .visual-panel {
                width: 100% !important;
            }
            
            /* Tool cards more compact on mobile */
            .tool-card {
                min-width: 150px;
                padding: 20px 16px;
            }
            
            .tool-card h3 {
                font-size: 1.1rem;
            }
            
            .tool-card p {
                font-size: 0.85rem;
            }
            
            /* Preview grids adapt to mobile */
            .preview-grid {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)) !important;
                gap: 12px !important;
            }
            
            /* Page cards larger touch targets */
            .page-card {
                min-height: 180px;
            }
            
            /* Buttons full width on mobile */
            .workspace > .btn,
            .control-panel > .btn,
            #btn-merge,
            #btn-imgs,
            #btn-compress {
                width: 100%;
                margin-top: 12px;
            }
            
            /* Upload areas more prominent */
            .upload-area {
                padding: 40px 24px;
                margin-bottom: 20px;
            }
            
            .upload-area p {
                font-size: 1.1rem;
            }
            
            /* Textareas mobile-friendly */
            textarea {
                min-height: 200px;
                font-size: 16px; /* Prevents zoom on iOS */
            }
            
            /* Inputs larger for touch */
            input[type="text"],
            input[type="number"],
            select {
                font-size: 16px; /* Prevents zoom on iOS */
                padding: 12px 14px;
            }
            
            /* Range sliders easier to use */
            input[type="range"] {
                height: 40px;
                padding: 8px 0;
            }
            
            /* Back button more prominent */
            .back-btn {
                padding: 10px 16px;
                font-size: 0.95rem;
            }
            
            /* Headers */
            .workspace h2 {
                font-size: 1.5rem;
                margin-bottom: 16px;
            }
            
            .workspace h4 {
                font-size: 1.1rem;
            }
        }
        
        /* Very small screens (< 400px) */
        @media (max-width: 400px) {
            .container {
                padding: 15px;
            }
            
            .workspace {
                padding: 15px;
            }
            
            .tools-grid {
                grid-template-columns: 1fr !important;
                gap: 12px;
            }
            
            .tool-card {
                min-width: unset;
            }
            
            .preview-grid {
                grid-template-columns: 1fr !important;
            }
            
            /* Merge list items */
            .merge-item {
                flex-direction: column;
                align-items: flex-start !important;
                gap: 8px;
            }
        }
        
        /* Touch-friendly icon buttons */
        @media (hover: none) and (pointer: coarse) {
            .icon-btn {
                min-width: 44px;
                min-height: 44px;
                font-size: 1.2rem;
            }
            
            .page-footer {
                padding: 12px;
                gap: 8px;
            }
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* ALIGNMENT FIX: FILENAME OVERFLOW - Comprehensive Text Truncation */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        /* Critical: Allow flex items to shrink below content size */
        .image-converter-row,
        .file-item,
        .page-card .page-footer,
        .img-preview-card,
        .image-card,
        .optimizer-result-card,
        .file-preview-item {
            min-width: 0 !important;
        }
        
        .image-info,
        .pdf-info,
        .file-info {
            min-width: 0 !important;
            flex: 1 !important;
        }
        
        /* Truncate long filenames with ellipsis in ALL contexts */
        .image-info > div:first-child,
        .pdf-info > div:first-child,
        .file-info > div:first-child,
        .page-footer > span:first-child,
        .img-preview-card h4,
        .optimizer-result-card h4,
        .page-card .page-footer span {
            white-space: nowrap !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
            width: 100% !important;
            display: block !important;
        }
        
        /* Ensure parent containers allow shrinking */
        .preview-grid .page-card,
        #img-preview-grid .page-card,
        #img-results-list > div {
            min-width: 0 !important;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* IMAGE CONVERTER - Status Badges & Responsive Layout */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 0.85rem;
            font-weight: 600;
            white-space: nowrap;
        }
        
        .status-pending {
            background: rgba(156, 163, 175, 0.1);
            color: #6B7280;
            border: 2px solid #9CA3AF;
        }
        
        .status-converting {
            background: rgba(99, 102, 241, 0.1);
            color: var(--primary);
            border: 2px solid var(--primary);
            animation: pulse 2s ease-in-out infinite;
        }
        
        .status-done {
            background: rgba(16, 185, 129, 0.1);
            color: #10B981;
            border: 2px solid #10B981;
        }
        
        .status-merged {
            background: rgba(99, 102, 241, 0.1);
            color: var(--primary);
            border: 2px solid var(--primary);
        }
        
        .status-error {
            background: rgba(239, 68, 68, 0.1);
            color: #EF4444;
            border: 2px solid #EF4444;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Mobile: Hide status text, show icon only */
        @media (max-width: 768px) {
            .status-text {
                display: none;
            }
            
            .status-badge {
                padding: 6px 10px;
                font-size: 1rem;
            }
            
            /* Image Converter: Vertical layout on mobile */
            .image-converter-row {
                flex-direction: column !important;
                align-items: stretch !important;
            }
            
            .image-info,
            .output-section,
            .status-section {
                min-width: 100% !important;
            }
            
            .output-section select {
                width: 100%;
            }
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* IMAGE CONVERTER - Sticky Action Bar Enhancement */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        #img-action-bar {
            border: 2px solid var(--primary) !important;
            animation: slideUpActionBar 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* ITEM 3: Bottom Action Bar - Fixed Positioning on Mobile */
        @media (max-width: 768px) {
            #img-action-bar {
                position: fixed !important;
                bottom: 0 !important;
                left: 0 !important;
                right: 0 !important;
                margin: 0 !important;
                border-radius: 20px 20px 0 0 !important;
                border-top: 2px solid var(--primary) !important;
                border-left: none !important;
                border-right: none !important;
                border-bottom: none !important;
                box-shadow: 0 -4px 20px rgba(0,0,0,0.15) !important;
                z-index: 9000 !important;
                padding-bottom: max(20px, env(safe-area-inset-bottom)) !important;
                background: var(--bg-card) !important;
                backdrop-filter: blur(10px);
            }
            
            /* Add padding to tool container so content isn't hidden behind bar */
            #tool-images {
                padding-bottom: 180px !important;
            }
            
            /* Also apply to other tools with action bars */
            #tool-img-comp {
                padding-bottom: 180px !important;
            }
            
            /* SHARE IMPLEMENTATION: Add padding for Sign PDF and Compress PDF */
            #tool-sign {
                padding-bottom: 180px !important;
            }
            
            #tool-compress {
                padding-bottom: 180px !important;
            }
        }
        
        @keyframes slideUpActionBar {
            from { 
                transform: translateY(30px); 
                opacity: 0; 
            }
            to { 
                transform: translateY(0); 
                opacity: 1; 
            }
        }
        
        /* Visual pulse for button when pending files exist */
        .btn.has-pending-files {
            animation: gentlePulse 2s ease-in-out infinite;
            box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.4);
        }
        
        @keyframes gentlePulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.4);
            }
            50% { 
                transform: scale(1.02);
                box-shadow: 0 0 0 8px rgba(99, 102, 241, 0);
            }
        }
        
        /* File upload staggered reveal animation */
        @keyframes rowFadeIn {
            from { 
                opacity: 0; 
                transform: translateY(10px);
            }
            to { 
                opacity: 1; 
                transform: translateY(0);
            }
        }
        
        /* Remove item animation - slide out + collapse */
        .removing {
            animation: rowRemove 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards !important;
        }
        
        @keyframes rowRemove {
            0% { 
                opacity: 1; 
                transform: translateX(0) scale(1);
                max-height: 300px;
                margin-bottom: 12px;
                padding: 16px;
            }
            50% {
                opacity: 0;
                transform: translateX(-30px) scale(0.95);
                max-height: 300px;
                margin-bottom: 12px;
                padding: 16px;
            }
            100% { 
                opacity: 0;
                transform: translateX(-30px) scale(0.95);
                max-height: 0;
                margin-bottom: 0;
                padding-top: 0;
                padding-bottom: 0;
                border-width: 0;
            }
        }
        
        /* ================== PHASE 3: PWA ENHANCEMENTS ================== */
        /* Enhanced spacing when running as installed PWA (standalone mode) */
        @media (display-mode: standalone) {
            /* Mobile PWA: Bigger touch targets and spacing */
            @media (max-width: 768px) {
                .upload-area {
                    min-height: 180px;
                    padding: 24px;
                }
                
                .btn {
                    padding: 16px 28px;
                    font-size: 1.05rem;
                }
                
                #menu {
                    gap: 20px;
                }
                
                .tool-card {
                    padding: 24px;
                }
            }
            
            /* Desktop PWA: More workspace and breathing room */
            @media (min-width: 769px) {
                .workspace {
                    max-width: 1400px;
                    padding: 40px;
                }
                
                .tool-card {
                    padding: 28px;
                }
                
                .upload-area {
                    min-height: 200px;
                }
            }
        }
        
        
        /* ================== MOBILE BUTTON LAYOUT FIX ================== */
        /* Move buttons below title on mobile to prevent overlap */
        @media (max-width: 768px) {
            #header-buttons {
                position: static !important;
                justify-content: center;
                margin-top: 12px;
                width: 100%;
            }
            
            header > div:first-child {
                flex-direction: column;
            }
        }
        
        /* ================== UPDATE NOTIFICATION STYLES ================== */
        .update-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(16, 185, 129, 0.4);
            font-weight: 600;
            cursor: pointer;
            z-index: 10000;
            animation: slideUp 0.3s ease;
            display: flex;
            align-items: center;
            gap: 12px;
            max-width: 90%;
        }
        
        .update-notification:hover {
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 12px 40px rgba(16, 185, 129, 0.5);
        }
        
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }
    </style>
</head>
<body>
<!-- Phase E: Skip link for keyboard navigation -->
<a href="#main-content" class="skip-link">Skip to main content</a>

<div id="toast">Success!</div>
<div class="loader" id="loader"><div class="spinner"></div><div style="font-weight:600; color: white !important; text-shadow: 0 2px 4px rgba(0,0,0,0.5);" id="loader-text">Processing...</div><div id="progress-bar"><div id="progress-fill"></div></div></div>

<div id="sig-toolbar">
    <div class="toolbar-group">
        <button class="btn btn-danger" style="margin:0; width:auto; padding:10px 15px;" onclick="deleteActiveSig()">Delete ğŸ—‘ï¸</button>
        <div style="flex:1; padding:0 10px;">
            <div style="display:flex; justify-content:space-between; font-size:0.8rem; margin-bottom:5px;">
                <span>Size</span><span id="sig-toolbar-val">150px</span>
            </div>
            <input type="range" id="sig-toolbar-slider" min="50" max="400" value="150" style="margin:0" oninput="resizeActiveSig(this.value)">
        </div>
    </div>
</div>

<div class="container">
    <!-- Phase E: Semantic landmarks for screen readers -->
    <header role="banner">
        <div style="display: flex; align-items: center; justify-content: center; position: relative; margin-bottom: 8px;">
            <h1 style="margin: 0;">ğŸ“„ PDF Toolkit Pro</h1>
            
            <!-- Buttons container positioned at the right -->
            <div id="header-buttons" style="position: absolute; right: 0; display: flex; gap: 8px;">
                <!-- PHASE 3: PWA Install Button (always visible) -->
                <button id="pwa-install-btn" class="theme-toggle" onclick="installPWA()" 
                        aria-label="Install App" title="Install as App">
                    ğŸ“±
                </button>
                
                <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle dark/light theme" title="Toggle Theme">ğŸŒ“</button>
            </div>
        </div>
        <p>Fast â€¢ Secure â€¢ Completely Offline</p>
    </header>

    <!-- PHASE 1.3: Search Bar -->
    <div class="search-container">
        <span class="search-icon">ğŸ”</span>
        <input 
            type="text" 
            class="search-bar" 
            id="tool-search" 
            placeholder="Search tools... (e.g., 'sign', 'merge', 'compress')"
            autocomplete="off"
        >
        <button class="search-clear" id="search-clear" onclick="clearSearch()" title="Clear search">Ã—</button>
    </div>

    <!-- Phase E: Main content landmark -->
    <main id="main-content" role="main">
        <nav aria-label="PDF tools" class="tools-grid" id="menu">
        <div class="tool-card" onclick="nav('sign')"><h3>âœï¸ Sign PDF</h3><p>Draw & tap to place</p></div>
        <div class="tool-card" onclick="nav('extract-text')"><h3>ğŸ“ Extract Text</h3><p>Copy text from PDFs</p></div>
        <div class="tool-card" onclick="nav('watermark')"><h3>ğŸ’§ Watermark</h3><p>Add text overlay</p></div>
        <div class="tool-card" onclick="nav('img-comp')"><h3>âœ¨ Image Optimizer</h3><p>Reduce size & resize</p></div>
        <div class="tool-card" onclick="nav('numbers')"><h3>ğŸ”¢ Page Numbers</h3><p>Add pagination</p></div>
        <div class="tool-card" onclick="nav('split')"><h3>âœ‚ï¸ Split PDF</h3><p>Extract pages</p></div>
        <div class="tool-card" onclick="nav('merge')"><h3>ğŸ“‘ Merge PDFs</h3><p>Combine files</p></div>
        <div class="tool-card" onclick="nav('rotate')"><h3>ğŸ”„ Rotate PDF</h3><p>Fix orientation</p></div>
        <div class="tool-card" onclick="nav('delete')"><h3>ğŸ—‘ï¸ Delete Pages</h3><p>Remove pages</p></div>
        <div class="tool-card" onclick="nav('images')"><h3>ğŸ”„ Image & PDF Converter</h3><p>Convert images & PDFs to any format</p></div>
        <div class="tool-card" onclick="nav('ocr')"><h3>ğŸ‘ï¸ OCR</h3><p>Image to text</p></div>
        <div class="tool-card" onclick="nav('metadata')"><h3>ğŸ·ï¸ Metadata</h3><p>Edit properties</p></div>
        <div class="tool-card" onclick="nav('text-pdf')"><h3>ğŸ“„ Text to PDF</h3><p>Notes to document</p></div>
        <div class="tool-card" onclick="nav('compress')"><h3>ğŸ“¦ Compress PDF</h3><p>Reduce file size</p></div>
    </div>

    <div class="workspace" id="tool-sign">
        <button class="back-btn" onclick="nav('home')">â† Back</button> <h2>Sign PDF</h2>
        
        <!-- STEP 1: Choose signature type -->
        <div id="sign-step-1" style="display:block;">
            <h3>Step 1: Create Your Signature</h3>
            
            <!-- Signature Type Tabs -->
            <div style="display:flex; gap:10px; margin-bottom:20px; border-bottom:2px solid var(--border); padding-bottom:0;">
                <button id="tab-draw" class="signature-tab active" onclick="switchSignatureTab('draw')" style="flex:1; padding:12px; border:none; background:none; cursor:pointer; font-weight:600; border-bottom:3px solid var(--primary); color:var(--primary);">
                    âœï¸ Draw Signature
                </button>
                <button id="tab-type" class="signature-tab" onclick="switchSignatureTab('type')" style="flex:1; padding:12px; border:none; background:none; cursor:pointer; font-weight:600; border-bottom:3px solid transparent; color:var(--text-muted);">
                    âŒ¨ï¸ Type Signature
                </button>
            </div>
            
            <!-- Draw Signature Panel -->
            <div id="draw-signature-panel" style="display:block;">
                <div style="margin-bottom:10px; display:flex; align-items:center; gap:10px;">
                    <label style="font-size:0.9rem; color:var(--text-muted)">Ink Color:</label>
                    <input type="color" id="sign-color" value="#0000ff" onchange="updateSignColor()" style="width:60px; height:40px; padding:0;">
                </div>
                <div class="drawing-box"><canvas id="sign-canvas"></canvas></div>
                <button class="btn-outline" onclick="clearSign()">Clear Canvas</button>
            </div>
            
            <!-- Type Signature Panel -->
            <div id="type-signature-panel" style="display:none;">
                <label style="font-size:0.9rem; color:var(--text-muted); display:block; margin-bottom:8px;">Enter Your Name:</label>
                <input type="text" id="typed-signature-input" placeholder="Your Full Name" style="font-size:1.2rem; margin-bottom:16px;" oninput="updateTypedSignature()">
                
                <label style="font-size:0.9rem; color:var(--text-muted); display:block; margin-bottom:8px;">Choose Font Style:</label>
                <select id="signature-font" onchange="updateTypedSignature()" style="margin-bottom:16px;">
                    <option value="'Brush Script MT', cursive">Brush Script (Handwritten)</option>
                    <option value="'Dancing Script', cursive">Dancing Script (Elegant)</option>
                    <option value="'Pacifico', cursive">Pacifico (Casual)</option>
                    <option value="'Great Vibes', cursive">Great Vibes (Fancy)</option>
                    <option value="'Allura', cursive">Allura (Stylish)</option>
                </select>
                
                <div style="margin-bottom:10px; display:flex; align-items:center; gap:10px;">
                    <label style="font-size:0.9rem; color:var(--text-muted)">Text Color:</label>
                    <input type="color" id="typed-sig-color" value="#0000ff" onchange="updateTypedSignature()" style="width:60px; height:40px; padding:0;">
                </div>
                
                <div style="background:white; border:2px solid var(--border); border-radius:12px; padding:40px 20px; text-align:center; min-height:150px; display:flex; align-items:center; justify-content:center;">
                    <div id="typed-signature-preview" style="font-size:3rem; color:#0000ff; font-family:'Brush Script MT', cursive;">Your Signature</div>
                </div>
            </div>
            
            <button class="btn" onclick="goToStep2()" style="margin-top:16px;">Next: Upload PDF â†’</button>
        </div>
        
        <!-- STEP 2: Upload PDF -->
        <div id="sign-step-2" style="display:none;">
            <button class="btn-outline" onclick="backToStep1()" style="width:auto; margin-bottom:15px;">â† Back to Signature</button>
            <div class="upload-area" onclick="document.getElementById('in-sign').click()">
                <p>ğŸ“‚ Select PDF to Sign</p>
            </div>
            <input type="file" id="in-sign" accept=".pdf" style="display:none">
        </div>
        
        <!-- STEP 3: Drag & Drop Signatures -->
        <div id="sign-step-3" style="display:none;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; flex-wrap:wrap; gap:10px;">
                <p style="color:var(--text-muted); font-size:0.9rem; margin:0;">Drag the signature from the panel to any page</p>
                <button class="btn" style="width:auto; margin:0; padding:10px 20px;" onclick="burnSignature()">Save Signed PDF</button>
            </div>
            
            <div style="display:grid; grid-template-columns: 1fr 280px; gap:20px;" class="sign-layout">
                <!-- PDF Pages Container -->
                <div id="pdf-sign-container" class="sign-area-wrapper" style="margin:0;"></div>
                
                <!-- Signature Panel (Draggable Source) -->
                <div class="signature-panel">
                    <h4>Your Signature</h4>
                    <div class="drag-instruction">Drag to any page</div>
                    
                    <!-- Draggable Signature Stamp -->
                    <div id="signature-stamp" draggable="true">
                        <img id="signature-stamp-img" style="max-width:100%; height:auto; pointer-events:none;">
                    </div>
                    
                    <div style="margin-top:15px;">
                        <label style="font-size:0.85rem; color:var(--text-secondary); display:block; margin-bottom:8px; font-weight:600;">Signature Size:</label>
                        <input type="range" id="stamp-size-slider" min="50" max="400" value="150" style="margin:0; margin-bottom:5px;" oninput="updateStampSize(this.value)">
                        <div style="text-align:center; font-size:0.85rem; color:var(--text-muted); font-weight:600;"><span id="stamp-size-val">150px</span></div>
                    </div>
                    
                    <button class="btn-outline" onclick="backToStep1()" style="margin-top:15px;">âœï¸ Edit Signature</button>
                </div>
            </div>
            
            <style>
                /* Responsive layout for mobile */
                @media (max-width: 768px) {
                    .sign-layout {
                        grid-template-columns: 1fr !important;
                    }
                    
                    /* Remove sticky positioning on mobile - let it scroll naturally */
                    .signature-panel {
                        position: relative !important;
                        top: 0 !important;
                        order: -1;
                        margin-bottom: 20px;
                        /* Make it less tall so it doesn't take up too much space */
                        max-height: none;
                    }
                    
                    /* On mobile, signature stamp should be more compact */
                    #signature-stamp {
                        min-height: 100px;
                    }
                }
            </style>
        </div>
        
        <!-- SHARE IMPLEMENTATION: Sign PDF Action Bar -->
        <div id="sign-action-bar" class="mobile-action-bar" style="display:none;">
            <button class="btn-outline" onclick="shareSignedPDF()" style="flex:1; margin:0; border-color:var(--primary); color:var(--primary);">
                ğŸ“¤ Share Signed PDF
            </button>
            <button class="btn" onclick="downloadSignedPDF()" style="flex:1; margin:0;">
                â¬‡ï¸ Download PDF
            </button>
        </div>
    </div>

    <div class="workspace" id="tool-extract-text">
        <button class="back-btn" onclick="nav('home')">â† Back</button> <h2>Extract Text</h2>
        <div class="upload-area" onclick="document.getElementById('in-extract').click()"><p>ğŸ“‚ Select PDF</p></div><input type="file" id="in-extract" accept=".pdf" style="display:none">
        <div class="split-layout" id="extract-editor" style="display:none">
            <div class="control-panel"><h4>Raw Text</h4><textarea id="extract-output"></textarea><button class="btn" onclick="downloadText()">Save .txt</button></div>
            <div class="visual-panel"><h4>Selectable Preview</h4><div id="extract-container" style="max-height:70vh;overflow-y:auto"></div></div>
        </div>
    </div>

    <div class="workspace" id="tool-watermark">
        <button class="back-btn" onclick="nav('home')">â† Back</button> <h2>Watermark PDF</h2>
        <div class="upload-area" onclick="document.getElementById('in-watermark').click()"><p>ğŸ“‚ Select PDF</p></div><input type="file" id="in-watermark" accept=".pdf" style="display:none">
        <div class="split-layout" id="watermark-editor" style="display:none">
            <div class="control-panel">
                <label>Text</label><input type="text" id="wm-text" value="DRAFT">
                <label>Color</label><input type="color" id="wm-color" value="#999999">
                <div class="slider-label"><span>Opacity</span><span id="wm-op-val">0.3</span></div><input type="range" id="wm-opacity" min="0.1" max="1" step="0.1" value="0.3" oninput="document.getElementById('wm-op-val').innerText=this.value">
                <div class="slider-label"><span>Size</span><span id="wm-sz-val">60</span></div><input type="range" id="wm-size" min="10" max="150" value="60" oninput="document.getElementById('wm-sz-val').innerText=this.value">
                <button class="btn" onclick="applyWatermark()">Apply</button>
            </div>
            <div class="visual-panel"><h4>Preview</h4><div class="preview-grid" id="watermark-grid"></div></div>
        </div>
    </div>


    <!-- ITEM 7: PDF to Image tool removed - functionality merged into Image & PDF Converter -->

    <div class="workspace" id="tool-img-comp">
        <button class="back-btn" onclick="nav('home')">â† Back</button>
        <h2>Image Optimizer</h2>
        <p style="text-align: center; color: var(--text-muted); margin: -8px 0 16px 0; font-size: 0.95rem;">Reduce size for web, email & documents</p>
        
        <!-- SINGLE BUTTON UI: Upload Images -->
        <div style="margin-bottom: 24px;">
            <!-- Desktop: Direct file picker, Mobile: Show modal -->
            <div class="upload-area img-optimizer-upload-btn" onclick="handleImageOptimizerUploadClick()" style="margin: 0;">
                <div style="font-size: 2.5rem;">ğŸ“</div>
                <p style="margin: 8px 0 0 0; font-size: 1rem; font-weight: 600;">Upload Images</p>
                <div style="font-size: 0.8rem; color: var(--text-muted);">Select files to optimize</div>
            </div>
        </div>
        
        <!-- Modal for Mobile: Choose upload method -->
        <div id="img-optimizer-upload-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); z-index: 9999; justify-content: center; align-items: center;">
            <div style="background: var(--bg-card); border-radius: 16px; padding: 24px; max-width: 90%; width: 400px; box-shadow: var(--shadow-lg);">
                <h3 style="margin: 0 0 20px 0; text-align: center; font-size: 1.2rem;">Choose an action</h3>
                
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <button onclick="selectImageOptimizerFiles()" style="display: flex; align-items: center; gap: 12px; padding: 16px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 12px; cursor: pointer; width: 100%; transition: all 0.3s;">
                        <div style="font-size: 2rem;">ğŸ“</div>
                        <div style="text-align: left; flex: 1;">
                            <div style="font-weight: 600; margin-bottom: 4px;">Select Files</div>
                            <div style="font-size: 0.85rem; color: var(--text-muted);">Choose from gallery</div>
                        </div>
                    </button>
                    
                    <button onclick="selectImageOptimizerCamera()" style="display: flex; align-items: center; gap: 12px; padding: 16px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 12px; cursor: pointer; width: 100%; transition: all 0.3s;">
                        <div style="font-size: 2rem;">ğŸ“¸</div>
                        <div style="text-align: left; flex: 1;">
                            <div style="font-weight: 600; margin-bottom: 4px;">Take Photo</div>
                            <div style="font-size: 0.85rem; color: var(--text-muted);">Use camera to scan</div>
                        </div>
                    </button>
                </div>
                
                <button onclick="closeImageOptimizerModal()" style="margin-top: 16px; width: 100%; padding: 12px; background: transparent; border: none; color: var(--text-muted); cursor: pointer; font-size: 0.9rem;">
                    Cancel
                </button>
            </div>
        </div>
        
        <input type="file" id="in-img-comp-files" multiple accept="image/*" style="display:none">
        <input type="file" id="in-img-comp-camera" accept="image/*" capture="environment" style="display:none">
        
        <div id="comp-editor" style="display:none;">
            <!-- HEIC Warning (shown if detected) -->
            <div id="heic-warning" style="display:none; background: rgba(239, 68, 68, 0.1); border: 2px solid #ef4444; border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                <p style="margin: 0; color: var(--text-main); font-size: 0.9rem; line-height: 1.5;">
                    âš ï¸ <strong>HEIC files detected!</strong><br>
                    Browser cannot process HEIC format. Please convert to JPG/PNG first using your device's photo app.
                </p>
            </div>
            
            <!-- Image Previews -->
            <div id="img-previews" style="margin-bottom: 24px;">
                <h4 style="margin-bottom: 12px; font-size: 1rem;">Selected Images</h4>
                
                <!-- Header with count and Add More button -->
                <div style="background: var(--bg-panel); padding: 16px; border-radius: 12px; margin-bottom: 16px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                    <p style="margin:0; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 1.5rem;">ğŸ“·</span>
                        <span><strong id="img-count" style="color: var(--primary); font-size: 1.2rem;">0</strong> <span style="color: var(--text-muted);">images</span></span>
                    </p>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn-outline" onclick="clearAllOptimizerImages()" style="margin: 0; width: auto; padding: 10px 18px; font-size: 0.9rem; border-color: var(--danger); color: var(--danger);">
                            ğŸ—‘ï¸ Clear All
                        </button>
                        <button class="btn-outline" onclick="addMoreOptimizerFiles()" style="margin: 0; width: auto; padding: 10px 18px; font-size: 0.9rem;">
                            ğŸ“ Add More Files
                        </button>
                    </div>
                </div>
                
                <div id="img-preview-grid" class="preview-grid" style="margin-bottom: 12px;"></div>
                <p id="img-total-size" style="text-align: center; color: var(--text-muted); font-size: 0.9rem; margin: 8px 0 0 0;"></p>
            </div>
            
            <!-- Quick Presets -->
            <div style="margin-bottom: 24px;">
                <h4 style="margin-bottom: 12px; font-size: 1rem;">Quick Presets</h4>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px;">
                    <button class="preset-btn" data-preset="document" onclick="selectPreset('document')" style="padding: 16px 12px; border-radius: 12px; cursor: pointer; transition: all 0.3s; text-align: center;">
                        <div style="font-size: 1.8rem; margin-bottom: 6px;">ğŸ“„</div>
                        <div class="preset-title" style="font-weight: 600; font-size: 0.9rem; margin-bottom: 4px;">Document</div>
                        <div style="font-size: 0.75rem; color: var(--text-muted);">For scans</div>
                    </button>
                    
                    <button class="preset-btn" data-preset="photo" onclick="selectPreset('photo')" style="padding: 16px 12px; border-radius: 12px; cursor: pointer; transition: all 0.3s; text-align: center;">
                        <div style="font-size: 1.8rem; margin-bottom: 6px;">ğŸ–¼ï¸</div>
                        <div class="preset-title" style="font-weight: 600; font-size: 0.9rem; margin-bottom: 4px;">Photo</div>
                        <div style="font-size: 0.75rem; color: var(--text-muted);">High quality</div>
                    </button>
                    
                    <button class="preset-btn" data-preset="web" onclick="selectPreset('web')" style="padding: 16px 12px; border-radius: 12px; cursor: pointer; transition: all 0.3s; text-align: center;">
                        <div style="font-size: 1.8rem; margin-bottom: 6px;">ğŸŒ</div>
                        <div class="preset-title" style="font-weight: 600; font-size: 0.9rem; margin-bottom: 4px;">Web</div>
                        <div style="font-size: 0.75rem; color: var(--text-muted);">Fast loading</div>
                    </button>
                </div>
            </div>
            
            <!-- OR Divider -->
            <div style="text-align: center; margin: 24px 0; position: relative;">
                <div style="position: absolute; top: 50%; left: 0; right: 0; height: 1px; background: var(--border);"></div>
                <span style="position: relative; background: var(--bg-main); padding: 0 12px; color: var(--text-muted); font-size: 0.85rem; font-weight: 600;">OR CUSTOMIZE</span>
            </div>
            
            <!-- Custom Options -->
            <div style="background: var(--bg-panel); padding: 20px; border-radius: 12px; margin-bottom: 20px;">
                <!-- Compression Level -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 12px; font-size: 0.95rem;">Compression Level</label>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <label class="comp-level-label" style="display: flex; align-items: center; padding: 12px; border: 2px solid var(--border); border-radius: 8px; cursor: pointer; transition: all 0.3s;">
                            <input type="radio" name="comp-level" value="high" style="margin-right: 10px; width: 18px; height: 18px;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; font-size: 0.9rem;">High Quality</div>
                                <div style="font-size: 0.75rem; color: var(--text-muted);">Best clarity, larger file</div>
                            </div>
                        </label>
                        
                        <label class="comp-level-label" style="display: flex; align-items: center; padding: 12px; border: 2px solid var(--primary); border-radius: 8px; cursor: pointer; transition: all 0.3s; background: rgba(99, 102, 241, 0.05);">
                            <input type="radio" name="comp-level" value="balanced" checked style="margin-right: 10px; width: 18px; height: 18px;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; font-size: 0.9rem; color: var(--primary);">Balanced</div>
                                <div style="font-size: 0.75rem; color: var(--text-muted);">Recommended</div>
                            </div>
                        </label>
                        
                        <label class="comp-level-label" style="display: flex; align-items: center; padding: 12px; border: 2px solid var(--border); border-radius: 8px; cursor: pointer; transition: all 0.3s;">
                            <input type="radio" name="comp-level" value="small" style="margin-right: 10px; width: 18px; height: 18px;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; font-size: 0.9rem;">Small Size</div>
                                <div style="font-size: 0.75rem; color: var(--text-muted);">Smallest file, lower quality</div>
                            </div>
                        </label>
                    </div>
                </div>
                
                <!-- Output Format -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 0.95rem;">Output Format</label>
                    <select id="comp-format" style="width: 100%; padding: 12px; border: 2px solid var(--border); border-radius: 8px; background: var(--bg-card); color: var(--text-main); font-size: 0.95rem;">
                        <option value="image/jpeg">JPG (Best for photos)</option>
                        <option value="image/png">PNG (Best for graphics)</option>
                        <option value="image/webp">WEBP (Best compression)</option>
                    </select>
                </div>
                
                <!-- Resize -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 0.95rem;">Resize</label>
                    <select id="comp-resize" style="width: 100%; padding: 12px; border: 2px solid var(--border); border-radius: 8px; background: var(--bg-card); color: var(--text-main); font-size: 0.95rem;">
                        <option value="0">Keep Original</option>
                        <option value="1920">Screen (1920px)</option>
                        <option value="1280" selected>Web (1280px)</option>
                        <option value="800">Email (800px)</option>
                    </select>
                </div>
                
                <!-- Preserve Text Toggle -->
                <div>
                    <label style="display: flex; align-items: center; cursor: pointer; padding: 12px; background: rgba(99, 102, 241, 0.05); border: 1px solid var(--primary); border-radius: 8px;">
                        <input type="checkbox" id="preserve-text" style="margin-right: 10px; width: 18px; height: 18px;">
                        <div>
                            <div style="font-weight: 600; font-size: 0.9rem;">Preserve text clarity</div>
                            <div style="font-size: 0.75rem; color: var(--text-muted);">Recommended for documents & screenshots</div>
                        </div>
                    </label>
                </div>
            </div>
            
            <!-- Before/After Preview (hidden initially) -->
            <div id="optimization-preview" style="display:none; background: var(--bg-panel); padding: 20px; border-radius: 12px; margin-bottom: 20px; border: 2px solid var(--border);">
                <h4 style="margin-bottom: 16px; text-align: center; font-size: 1rem;">Estimated Results</h4>
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 16px; align-items: center; margin-bottom: 16px;">
                    <div style="text-align: center;">
                        <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 4px;">Before</div>
                        <div style="font-size: 1.4rem; font-weight: 700; color: var(--text-main);" id="preview-before">0 MB</div>
                    </div>
                    <div style="font-size: 1.5rem; color: var(--text-muted);">â†’</div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 4px;">After</div>
                        <div style="font-size: 1.4rem; font-weight: 700; color: var(--primary);" id="preview-after">0 MB</div>
                    </div>
                </div>
                <div style="text-align: center; padding: 12px; background: rgba(16, 185, 129, 0.1); border-radius: 8px;">
                    <div style="font-size: 1.4rem; font-weight: 700; color: #10b981;">
                        ğŸ“‰ <span id="preview-reduction">0</span>% smaller
                    </div>
                </div>
            </div>
            
            <!-- Results (after processing) -->
            <div id="comp-results"></div>
            
            <!-- Process Button -->
            <button class="btn" id="btn-optimize" onclick="runImageOptimization()" style="width: 100%; font-size: 1.1rem; padding: 16px;">
                <span style="font-size: 1.2rem; margin-right: 8px;">âœ¨</span>
                Optimize Images
            </button>
        </div>
    </div>

    <div class="workspace" id="tool-split"><button class="back-btn" onclick="nav('home')">â† Back</button><h2>Split PDF</h2><div class="upload-area" id="split-upload" onclick="document.getElementById('in-split').click()"><p>ğŸ“‚ Select PDF</p></div><input type="file" id="in-split" accept=".pdf" style="display:none"><div class="split-layout" id="split-editor" style="display:none"><div class="control-panel"><input type="text" id="split-range" placeholder="e.g. 1, 3-5" onkeyup="syncVisualFromManual()"><button class="btn" onclick="saveSplit()">Extract</button></div><div class="visual-panel"><div class="preview-grid" id="split-grid"></div></div></div></div>
    
    <div class="workspace" id="tool-rotate"><button class="back-btn" onclick="nav('home')">â† Back</button><h2>Rotate Pages</h2><div class="upload-area" id="rotate-upload" onclick="document.getElementById('in-rotate').click()"><p>ğŸ“‚ Select PDF</p></div><input type="file" id="in-rotate" accept=".pdf" style="display:none"><div class="split-layout" id="rotate-editor" style="display:none"><div class="control-panel"><button class="btn-outline" onclick="rotateAll(90)">â†» All 90Â°</button><button class="btn" onclick="saveRotation()">Download</button></div><div class="visual-panel"><div class="preview-grid" id="rotate-grid"></div></div></div></div>
    
    <div class="workspace" id="tool-merge">
        <button class="back-btn" onclick="nav('home')">â† Back</button>
        <h2>Merge PDFs</h2>
        
        <div class="upload-area" onclick="document.getElementById('in-merge').click()">
            <p>ğŸ“‚ Add PDFs</p>
        </div>
        <input type="file" id="in-merge" multiple accept=".pdf" style="display:none">
        
        <!-- Header with count and buttons (shown when PDFs added) -->
        <div id="merge-controls" style="display:none; background: var(--bg-panel); padding: 16px; border-radius: 12px; margin: 16px 0; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
            <p style="margin:0; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 1.5rem;">ğŸ“„</span>
                <span><strong id="merge-count" style="color: var(--primary); font-size: 1.2rem;">0</strong> <span style="color: var(--text-muted);">PDFs</span></span>
            </p>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="btn-outline" onclick="clearAllMergePDFs()" style="margin: 0; width: auto; padding: 10px 18px; font-size: 0.9rem; border-color: var(--danger); color: var(--danger);">
                    ğŸ—‘ï¸ Clear All
                </button>
                <button class="btn-outline" onclick="document.getElementById('in-merge').click()" style="margin: 0; width: auto; padding: 10px 18px; font-size: 0.9rem;">
                    ğŸ“ Add More PDFs
                </button>
            </div>
        </div>
        
        <p style="text-align:center;font-size:0.8rem;color:var(--text-muted)">Drag items to reorder</p>
        <div id="merge-list" style="margin:20px 0; min-height:50px"></div>
        <button class="btn" id="btn-merge" onclick="saveMerge()" disabled>Merge PDFs</button>
    </div>

    <div class="workspace" id="tool-numbers">
        <button class="back-btn" onclick="nav('home')">â† Back</button>
        <h2>Page Numbers</h2>
        
        <div class="upload-area" onclick="document.getElementById('in-numbers').click()">
            <p>ğŸ“‚ Select PDF</p>
        </div>
        <input type="file" id="in-numbers" accept=".pdf" style="display:none">
        
        <div class="split-layout" id="numbers-editor" style="display:none">
            <div class="control-panel">
                <h4>Options</h4>
                <label>Number Position</label>
                <select id="num-pos">
                    <option value="bc">Bottom Center</option>
                    <option value="br">Bottom Right</option>
                    <option value="bl">Bottom Left</option>
                </select>
                <button class="btn" onclick="addPageNumbers()">Add Page Numbers</button>
            </div>
            <div class="visual-panel">
                <h4>PDF Preview</h4>
                <div class="preview-grid" id="numbers-grid"></div>
            </div>
        </div>
    </div>

    <div class="workspace" id="tool-ocr">
        <button class="back-btn" onclick="nav('home')">â† Back</button>
        <h2>OCR (Image to Text)</h2>
        
        <!-- SINGLE BUTTON UI: Upload Images -->
        <div style="margin-bottom: 24px;">
            <!-- Desktop: Direct file picker, Mobile: Show modal -->
            <div class="upload-area ocr-upload-btn" onclick="handleOCRUploadClick()" style="margin: 0;">
                <div style="font-size: 2.5rem;">ğŸ“</div>
                <p style="margin: 8px 0 0 0; font-size: 1rem; font-weight: 600;">Upload Images</p>
                <div style="font-size: 0.8rem; color: var(--text-muted);">Select image to extract text</div>
            </div>
        </div>
        
        <!-- Modal for Mobile: Choose upload method -->
        <div id="ocr-upload-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); z-index: 9999; justify-content: center; align-items: center;">
            <div style="background: var(--bg-card); border-radius: 16px; padding: 24px; max-width: 90%; width: 400px; box-shadow: var(--shadow-lg);">
                <h3 style="margin: 0 0 20px 0; text-align: center; font-size: 1.2rem;">Choose an action</h3>
                
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <button onclick="selectOCRFiles()" style="display: flex; align-items: center; gap: 12px; padding: 16px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 12px; cursor: pointer; width: 100%; transition: all 0.3s;">
                        <div style="font-size: 2rem;">ğŸ“</div>
                        <div style="text-align: left; flex: 1;">
                            <div style="font-weight: 600; margin-bottom: 4px;">Select Image</div>
                            <div style="font-size: 0.85rem; color: var(--text-muted);">Choose from gallery</div>
                        </div>
                    </button>
                    
                    <button onclick="selectOCRCamera()" style="display: flex; align-items: center; gap: 12px; padding: 16px; background: var(--bg-panel); border: 2px solid var(--border); border-radius: 12px; cursor: pointer; width: 100%; transition: all 0.3s;">
                        <div style="font-size: 2rem;">ğŸ“¸</div>
                        <div style="text-align: left; flex: 1;">
                            <div style="font-weight: 600; margin-bottom: 4px;">Take Photo</div>
                            <div style="font-size: 0.85rem; color: var(--text-muted);">Scan document</div>
                        </div>
                    </button>
                </div>
                
                <button onclick="closeOCRModal()" style="margin-top: 16px; width: 100%; padding: 12px; background: transparent; border: none; color: var(--text-muted); cursor: pointer; font-size: 0.9rem;">
                    Cancel
                </button>
            </div>
        </div>
        
        <input type="file" id="in-ocr-files" accept="image/*" style="display:none">
        <input type="file" id="in-ocr-camera" accept="image/*" capture="environment" style="display:none">
        
        <div id="ocr-editor" style="display:none">
            <div id="ocr-progress" style="margin-bottom:10px;font-weight:bold;color:var(--primary)"></div>
            <textarea id="ocr-output"></textarea>
            <button class="btn" onclick="copyOcr()">Copy Text</button>
        </div>
    </div>

    <div class="workspace" id="tool-metadata">
        <button class="back-btn" onclick="nav('home')">â† Back</button>
        <h2>PDF Metadata</h2>
        
        <div class="upload-area" onclick="document.getElementById('in-meta').click()">
            <p>ğŸ“‚ Select PDF</p>
        </div>
        <input type="file" id="in-meta" accept=".pdf" style="display:none">
        
        <div class="split-layout" id="meta-editor" style="display:none">
            <div class="control-panel">
                <h4>Edit Metadata</h4>
                
                <label>Document Title</label>
                <input type="text" id="meta-title" placeholder="Enter title">
                
                <label>Author</label>
                <input type="text" id="meta-author" placeholder="Enter author name">
                
                <div style="background: var(--bg-panel); padding: 16px; border-radius: 12px; margin: 16px 0;">
                    <h4 style="margin-bottom: 12px; font-size: 0.9rem;">Current Info</h4>
                    <p style="font-size: 0.85rem; color: var(--text-muted); margin: 4px 0;">
                        <strong>Filename:</strong> <span id="meta-filename">-</span>
                    </p>
                    <p style="font-size: 0.85rem; color: var(--text-muted); margin: 4px 0;">
                        <strong>Pages:</strong> <span id="meta-pages">-</span>
                    </p>
                    <p style="font-size: 0.85rem; color: var(--text-muted); margin: 4px 0;">
                        <strong>Size:</strong> <span id="meta-size">-</span>
                    </p>
                </div>
                
                <button class="btn" onclick="saveMetadata()">Update Metadata</button>
            </div>
            
            <div class="visual-panel">
                <h4>PDF Preview</h4>
                <div class="preview-grid" id="meta-grid"></div>
            </div>
        </div>
    </div>
    
    <div class="workspace" id="tool-delete"><button class="back-btn" onclick="nav('home')">â† Back</button><h2>Delete Pages</h2><div class="upload-area" id="delete-upload" onclick="document.getElementById('in-delete').click()"><p>ğŸ“‚ Select PDF</p></div><input type="file" id="in-delete" accept=".pdf" style="display:none"><div id="delete-editor" style="display:none"><p>Tap to remove</p><div class="preview-grid mode-delete" id="delete-grid"></div><button class="btn" style="background:var(--danger)" onclick="saveDelete()">Delete Selected</button></div></div>
    <div class="workspace" id="tool-compress">
        <button class="back-btn" onclick="nav('home')">â† Back</button>
        <h2>Compress PDF</h2>
        
        <div class="upload-area" onclick="document.getElementById('in-compress').click()" style="min-height: 140px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 12px;">
            <div style="font-size: 3rem;">ğŸ“¦</div>
            <p style="margin: 0; font-size: 1.1rem; font-weight: 600;">Select PDF to Compress</p>
            <p style="margin: 0; font-size: 0.85rem; color: var(--text-muted);">Reduce file size</p>
        </div>
        <input type="file" id="in-compress" accept=".pdf" style="display:none">
        
        <div id="compress-controls" style="display:none; margin-top:20px;">
            <!-- File Info Card -->
            <div style="background: var(--bg-panel); padding: 20px; border-radius: 12px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; justify-content: space-between; gap: 12px; margin-bottom: 16px; flex-wrap: wrap;">
                    <div style="display: flex; align-items: center; gap: 12px; flex: 1; min-width: 200px;">
                        <div style="font-size: 2rem;">ğŸ“„</div>
                        <div style="flex: 1;">
                            <p style="margin: 0; font-weight: 600; font-size: 1rem; color: var(--text-main);" id="compress-filename">document.pdf</p>
                            <p style="margin: 4px 0 0 0; font-size: 0.9rem; color: var(--text-muted);">
                                Original size: <strong id="compress-original-size" style="color: var(--primary);">0 MB</strong>
                            </p>
                        </div>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn-outline" onclick="clearCompressPDF()" style="margin: 0; width: auto; padding: 10px 18px; font-size: 0.9rem; border-color: var(--danger); color: var(--danger);">
                            ğŸ—‘ï¸ Clear
                        </button>
                        <button class="btn-outline" onclick="document.getElementById('in-compress').click()" style="margin: 0; width: auto; padding: 10px 18px; font-size: 0.9rem;">
                            ğŸ“ Add Another PDF
                        </button>
                    </div>
                </div>
                
                <!-- Compression Mode Selector -->
                <div style="margin-top: 20px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 12px; font-size: 1rem;">Compression Mode:</label>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 20px;">
                        <!-- Structure Optimization Mode -->
                        <div class="compression-mode" data-mode="structure" onclick="selectCompressionMode('structure')" style="padding: 16px; border: 2px solid var(--border); border-radius: 12px; cursor: pointer; transition: all 0.3s;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                <div style="font-size: 1.5rem;">âš¡</div>
                                <div style="font-weight: 600; font-size: 1rem;">Optimize Structure</div>
                            </div>
                            <div style="font-size: 0.8rem; color: var(--text-muted); line-height: 1.4;">
                                â€¢ Fast & lossless<br>
                                â€¢ Text stays selectable<br>
                                â€¢ 5-15% reduction<br>
                                â€¢ Best for digital PDFs
                            </div>
                        </div>
                        
                        <!-- Image-Based Compression Mode -->
                        <div class="compression-mode selected" data-mode="image" onclick="selectCompressionMode('image')" style="padding: 16px; border: 2px solid var(--primary); border-radius: 12px; cursor: pointer; transition: all 0.3s; background: rgba(99, 102, 241, 0.05);">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                <div style="font-size: 1.5rem;">ğŸ–¼ï¸</div>
                                <div style="font-weight: 600; font-size: 1rem; color: var(--primary);">Compress Images</div>
                            </div>
                            <div style="font-size: 0.8rem; color: var(--text-muted); line-height: 1.4;">
                                â€¢ Aggressive compression<br>
                                â€¢ 30-80% reduction<br>
                                â€¢ Text becomes image<br>
                                â€¢ Best for scanned PDFs
                            </div>
                        </div>
                    </div>
                    
                    <!-- POWER COMBO: Color Mode + Quality Presets (replaces slider) -->
                    <div id="image-quality-control" style="margin-top: 16px;">
                        
                        <!-- Step 1: Color Mode -->
                        <div style="padding: 20px; background: var(--bg-card); border-radius: 12px; border: 2px solid var(--border); margin-bottom: 16px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 12px; font-size: 1rem; display: flex; align-items: center; gap: 8px;">
                                <span style="background: var(--primary); color: white; width: 24px; height: 24px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; font-size: 0.8rem;">1</span>
                                Color Mode
                            </label>
                            
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 12px;">
                                <!-- Color Option -->
                                <button class="color-mode-option selected" data-mode="color" onclick="updateColorMode('color')" style="padding: 16px 12px; border: 2px solid var(--primary); background: rgba(99, 102, 241, 0.05); border-radius: 12px; cursor: pointer; transition: all 0.2s; text-align: center;">
                                    <div style="font-size: 1.8rem; margin-bottom: 6px;">ğŸŒˆ</div>
                                    <div style="font-weight: 600; font-size: 0.9rem; margin-bottom: 4px; color: var(--text-main);">Color</div>
                                    <div style="font-size: 0.7rem; color: var(--text-muted);">Best for photos</div>
                                </button>
                                
                                <!-- Grayscale Option -->
                                <button class="color-mode-option" data-mode="grayscale" onclick="updateColorMode('grayscale')" style="padding: 16px 12px; border: 2px solid var(--border); background: transparent; border-radius: 12px; cursor: pointer; transition: all 0.2s; text-align: center;">
                                    <div style="font-size: 1.8rem; margin-bottom: 6px;">ğŸŒ‘</div>
                                    <div style="font-weight: 600; font-size: 0.9rem; margin-bottom: 4px; color: var(--text-main);">Grayscale</div>
                                    <div style="font-size: 0.7rem; color: var(--text-muted);">For documents</div>
                                    <div style="font-size: 0.7rem; color: var(--primary); margin-top: 4px; font-weight: 600;">+30% savings</div>
                                </button>
                                
                                <!-- Black & White Option -->
                                <button class="color-mode-option" data-mode="bw" onclick="updateColorMode('bw')" style="padding: 16px 12px; border: 2px solid var(--border); background: transparent; border-radius: 12px; cursor: pointer; transition: all 0.2s; text-align: center;">
                                    <div style="font-size: 1.8rem; margin-bottom: 6px;">ğŸ</div>
                                    <div style="font-weight: 600; font-size: 0.9rem; margin-bottom: 4px; color: var(--text-main);">B&W</div>
                                    <div style="font-size: 0.7rem; color: var(--text-muted);">Text only</div>
                                    <div style="font-size: 0.7rem; color: var(--primary); margin-top: 4px; font-weight: 600;">+70% savings</div>
                                </button>
                            </div>
                            
                            <div id="color-mode-hint" style="padding: 10px; background: rgba(99, 102, 241, 0.05); border-radius: 8px; font-size: 0.8rem; color: var(--text-secondary); text-align: center;">
                                ğŸ’¡ Keeps original colors - best for photos & graphics
                            </div>
                        </div>
                        
                        <!-- Step 2: Compression Level -->
                        <div style="padding: 20px; background: var(--bg-card); border-radius: 12px; border: 2px solid var(--border);">
                            <label style="display: block; font-weight: 600; margin-bottom: 12px; font-size: 1rem; display: flex; align-items: center; gap: 8px;">
                                <span style="background: var(--primary); color: white; width: 24px; height: 24px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; font-size: 0.8rem;">2</span>
                                Compression Level
                            </label>
                            
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 12px;">
                                <!-- Email Preset -->
                                <button class="compression-preset" data-quality="email" onclick="updateCompressionQuality('email')" style="padding: 16px 12px; border: 2px solid var(--border); background: transparent; border-radius: 12px; cursor: pointer; transition: all 0.2s; text-align: center;">
                                    <div style="font-size: 1.8rem; margin-bottom: 6px;">ğŸ“§</div>
                                    <div style="font-weight: 600; font-size: 0.9rem; margin-bottom: 4px; color: var(--text-main);">Email</div>
                                    <div style="font-size: 0.7rem; color: var(--text-muted);">Smallest size</div>
                                    <div style="font-size: 0.7rem; color: var(--primary); margin-top: 4px; font-weight: 600;">~80% smaller</div>
                                </button>
                                
                                <!-- Balanced Preset (Default) -->
                                <button class="compression-preset selected" data-quality="balanced" onclick="updateCompressionQuality('balanced')" style="padding: 16px 12px; border: 2px solid var(--primary); background: rgba(99, 102, 241, 0.05); border-radius: 12px; cursor: pointer; transition: all 0.2s; text-align: center;">
                                    <div style="font-size: 1.8rem; margin-bottom: 6px;">ğŸ“„</div>
                                    <div style="font-weight: 600; font-size: 0.9rem; margin-bottom: 4px; color: var(--text-main);">Balanced</div>
                                    <div style="font-size: 0.7rem; color: var(--text-muted);">Recommended</div>
                                    <div style="font-size: 0.7rem; color: var(--primary); margin-top: 4px; font-weight: 600;">~60% smaller</div>
                                </button>
                                
                                <!-- High Quality Preset -->
                                <button class="compression-preset" data-quality="high" onclick="updateCompressionQuality('high')" style="padding: 16px 12px; border: 2px solid var(--border); background: transparent; border-radius: 12px; cursor: pointer; transition: all 0.2s; text-align: center;">
                                    <div style="font-size: 1.8rem; margin-bottom: 6px;">ğŸ–¼ï¸</div>
                                    <div style="font-weight: 600; font-size: 0.9rem; margin-bottom: 4px; color: var(--text-main);">High Quality</div>
                                    <div style="font-size: 0.7rem; color: var(--text-muted);">Best look</div>
                                    <div style="font-size: 0.7rem; color: var(--primary); margin-top: 4px; font-weight: 600;">~35% smaller</div>
                                </button>
                            </div>
                            
                            <div id="quality-hint" style="padding: 10px; background: rgba(99, 102, 241, 0.05); border-radius: 8px; font-size: 0.8rem; color: var(--text-secondary); text-align: center;">
                                ğŸ“Š Balanced compression - recommended for most PDFs
                            </div>
                        </div>
                    </div>
                    
                    <!-- Structure Optimization Info (only for structure mode) -->
                    <div id="structure-info" style="display:none; margin-top: 16px; padding: 12px 16px; background: rgba(99, 102, 241, 0.05); border-radius: 10px; border: 1px solid var(--primary);">
                        <p style="margin: 0; font-size: 0.85rem; color: var(--text-secondary);">
                            â„¹ï¸ This mode optimizes PDF structure without modifying content. Best for digital PDFs. For scanned documents or image-heavy PDFs, use "Compress Images" mode for better results.
                        </p>
                    </div>
                </div>
            </div>
            
            <!-- Results Card (Hidden initially) -->
            <div id="compress-results" style="display:none; background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(5, 150, 105, 0.05) 100%); border: 2px solid #10b981; padding: 20px; border-radius: 12px; margin-bottom: 20px;">
                <div style="text-align: center; margin-bottom: 16px;">
                    <div style="font-size: 2.5rem; margin-bottom: 8px;">âœ…</div>
                    <h3 style="margin: 0 0 8px 0; color: #10b981; font-size: 1.3rem;">Compression Complete!</h3>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 16px; align-items: center; margin-bottom: 16px;">
                    <div style="text-align: center;">
                        <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 4px;">Original</div>
                        <div style="font-size: 1.4rem; font-weight: 700; color: var(--text-main);" id="result-original-size">0 MB</div>
                    </div>
                    
                    <div style="font-size: 1.5rem; color: var(--text-muted);">â†’</div>
                    
                    <div style="text-align: center;">
                        <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 4px;">Compressed</div>
                        <div style="font-size: 1.4rem; font-weight: 700; color: #10b981;" id="result-compressed-size">0 MB</div>
                    </div>
                </div>
                
                <div style="text-align: center; padding: 12px; background: rgba(16, 185, 129, 0.1); border-radius: 8px;">
                    <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 4px;">Space Saved</div>
                    <div style="font-size: 1.6rem; font-weight: 700; color: #10b981;">
                        <span id="result-saved-size">0 MB</span>
                        <span style="font-size: 1.2rem; margin-left: 8px;">(<span id="result-saved-percent">0</span>%)</span>
                    </div>
                </div>
            </div>
            
            <button class="btn" id="btn-compress" onclick="compressPDF()">
                <span style="font-size: 1.2rem; margin-right: 8px;">âš¡</span>
                Compress PDF
            </button>
        </div>
        
        <!-- SHARE IMPLEMENTATION: Compress PDF Action Bar -->
        <div id="compress-action-bar" class="mobile-action-bar" style="display:none;">
            <button class="btn-outline" onclick="shareCompressedPDF()" style="flex:1; margin:0; border-color:var(--primary); color:var(--primary);">
                ğŸ“¤ Share Compressed PDF
            </button>
            <button class="btn" onclick="downloadCompressedPDF()" style="flex:1; margin:0;">
                â¬‡ï¸ Download PDF
            </button>
        </div>
    </div>
    <div class="workspace" id="tool-text-pdf"><button class="back-btn" onclick="nav('home')">â† Back</button><h2>Text to PDF</h2><textarea id="text-pdf-input" placeholder="Type notes..."></textarea><button class="btn" onclick="saveTextToPdf()">Save PDF</button></div>
    <div class="workspace" id="tool-images">
        <button class="back-btn" onclick="nav('home')">â† Back</button>
        <h2>Image Converter</h2>
        <p style="color: var(--text-muted); margin: -8px 0 20px 0; font-size: 0.9rem;">Convert images & PDFs to any format</p>
        
        <div class="upload-area" onclick="document.getElementById('in-imgs').click()" style="min-height: 140px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 12px;">
            <div style="font-size: 3rem;">ğŸ”„</div>
            <p style="margin: 0; font-size: 1.1rem; font-weight: 600;">Select Images or PDFs</p>
            <p style="margin: 0; font-size: 0.85rem; color: var(--text-muted);">JPG, PNG, WebP, PDF supported â€¢ Max 10 files</p>
        </div>
        <input type="file" id="in-imgs" multiple accept="image/*,.pdf,application/pdf" style="display:none">
        
        <div id="img-controls" style="display:none; margin-top:20px;">
            <!-- Add More Files Button + Clear All -->
            <div style="background: var(--bg-panel); padding: 16px; border-radius: 12px; margin-bottom: 16px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                <p style="margin:0; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 1.5rem;">ğŸ“·</span>
                    <span><strong id="img-count" style="color: var(--primary); font-size: 1.2rem;">0</strong> <span style="color: var(--text-muted);">images</span></span>
                </p>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="btn-outline" onclick="clearAllImages()" style="margin: 0; width: auto; padding: 10px 18px; font-size: 0.9rem; border-color: var(--danger); color: var(--danger);">
                        ğŸ—‘ï¸ Clear All
                    </button>
                    <button class="btn-outline" onclick="document.getElementById('in-imgs').click()" style="margin: 0; width: auto; padding: 10px 18px; font-size: 0.9rem;">
                        ğŸ“ Add More Files
                    </button>
                </div>
            </div>
            
            <!-- Image List View -->
            <div id="img-list" style="margin-bottom:20px;"></div>
            
            <!-- Bottom Action Bar (Sticky on mobile) -->
            <div id="img-action-bar" style="display: none; background: var(--bg-panel); padding: 20px; border-radius: 12px; position: sticky; bottom: 20px; box-shadow: 0 -2px 10px rgba(0,0,0,0.1);">
                <!-- Convert All Selector -->
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600; font-size: 0.95rem;">Convert All (<span id="img-count-bar">0</span>) to:</label>
                    <select id="convert-all-format" onchange="applyConvertAll()" style="width: 100%; padding: 12px; font-size: 16px; border-radius: 8px; border: 2px solid var(--border); background: var(--bg-card);">
                        <option value="">Select format...</option>
                        <option value="jpg">JPG (Photos)</option>
                        <option value="png">PNG (Transparent)</option>
                        <option value="webp">WebP (Web Optimized)</option>
                        <option value="pdf">PDF (Document)</option>
                    </select>
                </div>
                
                <!-- PDF Merge Checkbox (Conditional) -->
                <div id="pdf-merge-container" style="display: none; margin-bottom: 16px; padding: 12px; background: var(--bg-card); border-radius: 8px; border: 2px solid var(--primary-light);">
                    <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 0.95rem;">
                        <input type="checkbox" id="merge-pdfs-checkbox" style="width: 20px; height: 20px; cursor: pointer;">
                        <span>ğŸ“‘ Merge all PDFs into one document</span>
                    </label>
                    <p style="margin: 8px 0 0 30px; font-size: 0.8rem; color: var(--text-muted);">
                        Unchecked: Creates separate PDF files (in ZIP)
                    </p>
                </div>
                
                <!-- Convert Button -->
                <button class="btn" onclick="convertAllImages()" style="width: 100%; padding: 16px; display: flex; align-items: center; justify-content: center; gap: 8px; font-size: 1.05rem;">
                    <span>Convert Images</span>
                    <span>â†’</span>
                </button>
            </div>
            
            <!-- Results Section (Hidden initially) -->
            <div id="img-results" style="display:none; margin-top:20px;">
                <h3 style="margin-bottom: 16px;">Conversion Results</h3>
                <div id="img-results-list" style="margin-bottom:20px;"></div>
                
                <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                    <button class="btn-outline" onclick="resetImageConverter()" style="flex: 1; min-width: 160px;">
                        ğŸ”„ Convert More
                    </button>
                    <button class="btn" onclick="downloadAllResults()" id="download-all-btn" style="flex: 2; min-width: 200px;">
                        ğŸ“¦ Download All (ZIP)
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    </main><!-- End main content -->

</div><!-- End container -->

<script>
    const { PDFDocument, degrees, rgb, StandardFonts } = PDFLib;
    
    // THEME
    function toggleTheme() {
        const next = document.documentElement.getAttribute('data-theme')==='dark'?'light':'dark';
        document.documentElement.setAttribute('data-theme', next); localStorage.setItem('theme', next);
    }
    document.documentElement.setAttribute('data-theme', localStorage.getItem('theme') || 'light');

    function showToast(msg) {
        const t = document.getElementById("toast"); t.innerText = msg; t.className = "show";
        setTimeout(() => { t.className = t.className.replace("show", ""); }, 3000);
        
        // PHASE 1.4: Add haptic feedback based on message type
        if (typeof vibrate === 'function') {
            if (msg.includes('âœ…') || msg.includes('Downloaded') || msg.includes('complete')) {
                vibrate([10, 50, 10]); // Success pattern
            } else if (msg.includes('âŒ') || msg.includes('failed') || msg.includes('Error')) {
                vibrate([50, 100, 50]); // Error pattern
            } else if (msg.includes('âš ï¸')) {
                vibrate([30, 100, 30]); // Warning pattern
            } else {
                vibrate(15); // Default light feedback
            }
        }
    }

    let files = {};
    let states = { rotate: new Map(), delete: new Set(), split: new Set(), merge: [], images: [], imgCompFiles: [], placedSigs: [], activeSig: null };

    // LAZY & NAV
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(e => { if(e.isIntersecting && e.target.renderFn) { e.target.renderFn(); e.target.renderFn=null; observer.unobserve(e.target); } });
    }, {rootMargin: "200px"});

    function nav(id) {
        document.querySelectorAll('input').forEach(i=>{if(i.type!=='range'&&i.type!=='color')i.value=''});
        
        // Clear specific grids but preserve img-grid if staying in images tool
        if(id !== 'images') {
            document.querySelectorAll('.preview-grid, #merge-list, #comp-results, #extract-container, #pdf-sign-container').forEach(g=>g.innerHTML='');
        } else {
            // Only clear non-image grids
            document.querySelectorAll('#merge-list, #comp-results, #extract-container, #pdf-sign-container').forEach(g=>g.innerHTML='');
        }
        
        document.getElementById('menu').style.display = id==='home'?'grid':'none';
        document.querySelectorAll('.workspace').forEach(w=>{w.classList.remove('active'); w.style.display='none'});
        document.getElementById('sig-toolbar').classList.remove('active');
        
        // CRITICAL FIX: Conditional action bar cleanup
        // Only hide action bars when navigating AWAY from their tools
        if (id !== 'sign') {
            const signActionBar = document.getElementById('sign-action-bar');
            if (signActionBar) signActionBar.style.display = 'none';
            window.lastSignedPDF = null;
        }
        
        if (id !== 'compress') {
            const compressActionBar = document.getElementById('compress-action-bar');
            if (compressActionBar) compressActionBar.style.display = 'none';
            window.lastCompressedPDF = null;
        }
        
        // img-action-bar is used by both img-comp (Image Optimizer) and images (Image Converter)
        if (id !== 'img-comp' && id !== 'images') {
            const imgActionBar = document.getElementById('img-action-bar');
            if (imgActionBar) imgActionBar.style.display = 'none';
        }
        
        if(id!=='home') {
            const el = document.getElementById(`tool-${id}`); 
            el.classList.add('active'); 
            el.style.display='block';
            
            if(el.querySelector('.upload-area')) el.querySelector('.upload-area').style.display='block';
            
            // Don't hide img-grid when opening images tool
            const editorsToHide = el.querySelector('.split-layout')||el.querySelector('#delete-editor')||el.querySelector('#sign-step-2')||el.querySelector('#extract-editor')||el.querySelector('#numbers-editor')||el.querySelector('#ocr-editor')||el.querySelector('#meta-editor');
            if(editorsToHide && id !== 'images') {
                editorsToHide.style.display='none';
            }
            
            // Hide img-controls initially, will show when images uploaded
            if(id === 'images') {
                const imgControls = document.getElementById('img-controls');
                if(imgControls && states.images.length === 0) {
                    imgControls.style.display='none';
                }
            }
            
            if(id==='sign') { 
                document.getElementById('sign-step-1').style.display='block'; 
                document.getElementById('sign-step-2').style.display='none'; 
                document.getElementById('sign-step-3').style.display='none';
                switchSignatureTab('draw'); // Reset to draw mode
                setTimeout(initSignCanvas, 100);
            }
        }
        
        // Reset states
        files = {}; 
        states = { 
            rotate: new Map(), 
            delete: new Set(), 
            split: new Set(), 
            merge: [], 
            images: [], 
            imgCompFiles: [], 
            placedSigs: [], 
            activeSig: null 
        };
    }

    // ==================== PHASE 1 & 2: MOBILE ENHANCEMENTS ====================
    
    // PHASE 1.3: Search Bar Functionality
    const toolSearchData = {
        'sign': ['sign', 'signature', 'draw', 'type', 'autograph', 'sign pdf'],
        'extract-text': ['extract', 'text', 'copy', 'get text', 'pdf text'],
        'watermark': ['watermark', 'overlay', 'text overlay', 'stamp', 'mark'],
        'img-comp': ['image', 'optimizer', 'compress', 'reduce', 'resize', 'optimize', 'photo'],
        'numbers': ['page', 'numbers', 'pagination', 'numbering', 'page numbers'],
        'split': ['split', 'extract', 'pages', 'separate', 'divide'],
        'merge': ['merge', 'combine', 'join', 'unite', 'concat', 'pdf'],
        'rotate': ['rotate', 'turn', 'orientation', 'flip'],
        'delete': ['delete', 'remove', 'pages', 'erase'],
        'images': ['image', 'convert', 'converter', 'pdf to image', 'jpg', 'png', 'webp'],
        'ocr': ['ocr', 'scan', 'image to text', 'recognize', 'extract text from image'],
        'metadata': ['metadata', 'properties', 'info', 'details', 'title', 'author'],
        'text-pdf': ['text', 'pdf', 'notes', 'create', 'text to pdf', 'write'],
        'compress': ['compress', 'reduce', 'shrink', 'smaller', 'optimize', 'pdf']
    };
    
    function initSearchBar() {
        const searchInput = document.getElementById('tool-search');
        const searchClear = document.getElementById('search-clear');
        const toolCards = document.querySelectorAll('.tool-card');
        
        searchInput.addEventListener('input', function(e) {
            const query = e.target.value.toLowerCase().trim();
            
            // Show/hide clear button
            if (query.length > 0) {
                searchClear.classList.add('visible');
            } else {
                searchClear.classList.remove('visible');
            }
            
            // Filter tools
            let visibleCount = 0;
            toolCards.forEach(card => {
                const toolId = card.getAttribute('onclick').match(/'([^']+)'/)[1];
                const keywords = toolSearchData[toolId] || [];
                const matches = keywords.some(keyword => keyword.includes(query));
                
                if (query === '' || matches) {
                    card.style.display = '';
                    card.style.opacity = '1';
                    card.style.transform = 'scale(1)';
                    visibleCount++;
                } else {
                    card.style.display = 'none';
                    card.style.opacity = '0';
                    card.style.transform = 'scale(0.9)';
                }
            });
            
            // Haptic feedback on search (light)
            if (query.length === 1) {
                vibrate(5);
            }
        });
        
        // ITEM 6: Keyboard shortcuts (removed / focus, kept ESC clear)
        document.addEventListener('keydown', function(e) {
            // ESC to clear search
            if (e.key === 'Escape' && document.activeElement === searchInput) {
                clearSearch();
            }
        });
    }
    
    function clearSearch() {
        const searchInput = document.getElementById('tool-search');
        const searchClear = document.getElementById('search-clear');
        searchInput.value = '';
        searchClear.classList.remove('visible');
        
        // Show all cards
        document.querySelectorAll('.tool-card').forEach(card => {
            card.style.display = '';
            card.style.opacity = '1';
            card.style.transform = 'scale(1)';
        });
        
        vibrate(5);
    }
    
    // PHASE 1.4: Haptic Feedback
    function vibrate(pattern = 10) {
        if ('vibrate' in navigator) {
            navigator.vibrate(pattern);
        }
    }
    
    // Haptic patterns
    const HAPTIC = {
        light: 10,
        medium: 20,
        heavy: 30,
        success: [10, 50, 10],
        error: [50, 100, 50, 100, 50],
        warning: [30, 100, 30]
    };
    
    // PHASE 1.2: Native Share API
    async function shareFile(blob, filename) {
        // Check if Web Share API is supported
        if (navigator.share && navigator.canShare) {
            try {
                const file = new File([blob], filename, { type: blob.type });
                
                if (navigator.canShare({ files: [file] })) {
                    await navigator.share({
                        files: [file],
                        title: 'PDF Toolkit Pro',
                        text: `Sharing ${filename}`
                    });
                    
                    showToast('âœ… Shared successfully!');
                    vibrate(HAPTIC.success);
                    return true;
                }
            } catch (err) {
                // User cancelled or error occurred
                if (err.name !== 'AbortError') {
                    console.error('Share failed:', err);
                    showToast('âš ï¸ Share cancelled');
                }
                return false;
            }
        }
        
        // Fallback to download if share not supported
        download(blob, filename);
        return false;
    }
    
    // Check if device supports sharing
    function canShare() {
        return navigator.share && navigator.canShare;
    }
    
    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
        initSearchBar();
        
        // Add haptic feedback to existing button clicks
        document.addEventListener('click', function(e) {
            if (e.target.matches('.btn, .btn-outline, .tool-card')) {
                vibrate(HAPTIC.light);
            }
        });
        
        // ITEM 2: Type Signature Font Live Update
        // Bind font selector to update signature preview instantly
        const fontSelect = document.getElementById('signature-font');
        if (fontSelect) {
            // Use both 'input' (immediate) and 'change' (commit) events
            fontSelect.addEventListener('input', updateTypedSignature);
            fontSelect.addEventListener('change', updateTypedSignature);
        }
    });

    function loading(show, text="Processing...") { 
        document.getElementById('loader').style.display = show ? 'flex' : 'none'; 
        document.getElementById('loader-text').innerText = text;
        document.getElementById('progress-fill').style.width = '0%';
    }

    // ================== SIGNATURE (DRAG & DROP + DRAW/TYPE) ==================
    let signCanvas, signCtx, isDrawing = false, sigData = null, currentSigSize = 150;
    let signatureMode = 'draw'; // 'draw' or 'type'
    let isPlaceMode = false; // For mobile tap-to-place
    let isTouchDevice = false;
    
    // Detect if touch device
    function detectTouchDevice() {
        isTouchDevice = ('ontouchstart' in window) || 
                       (navigator.maxTouchPoints > 0) || 
                       (navigator.msMaxTouchPoints > 0);
        return isTouchDevice;
    }
    
    function switchSignatureTab(mode) {
        signatureMode = mode;
        
        // Update tab styling
        document.getElementById('tab-draw').style.borderBottom = mode === 'draw' ? '3px solid var(--primary)' : '3px solid transparent';
        document.getElementById('tab-draw').style.color = mode === 'draw' ? 'var(--primary)' : 'var(--text-muted)';
        document.getElementById('tab-type').style.borderBottom = mode === 'type' ? '3px solid var(--primary)' : '3px solid transparent';
        document.getElementById('tab-type').style.color = mode === 'type' ? 'var(--primary)' : 'var(--text-muted)';
        
        // Show/hide panels
        document.getElementById('draw-signature-panel').style.display = mode === 'draw' ? 'block' : 'none';
        document.getElementById('type-signature-panel').style.display = mode === 'type' ? 'block' : 'none';
        
        // FONT FIX: Attach event listeners when switching to type mode
        if (mode === 'type') {
            setTimeout(() => {
                const fontSelect = document.getElementById('signature-font');
                const textInput = document.getElementById('typed-signature-input');
                const colorPicker = document.getElementById('typed-sig-color');
                
                
                if (fontSelect) {
                    // Remove old listeners first (prevent duplicates)
                    fontSelect.removeEventListener('input', updateTypedSignature);
                    fontSelect.removeEventListener('change', updateTypedSignature);
                    
                    // Add new listeners
                    fontSelect.addEventListener('input', updateTypedSignature);
                    fontSelect.addEventListener('change', updateTypedSignature);
                    
                } 
                
                // Also attach to text input and color picker for completeness
                if (textInput) {
                    textInput.removeEventListener('input', updateTypedSignature);
                    textInput.addEventListener('input', updateTypedSignature);
                }
                if (colorPicker) {
                    colorPicker.removeEventListener('input', updateTypedSignature);
                    colorPicker.addEventListener('input', updateTypedSignature);
                }
                
                // Trigger initial update to ensure preview shows correct font
                updateTypedSignature();
            }, 100);
        }
    }
    
    function initSignCanvas() {
        signCanvas = document.getElementById('sign-canvas');
        if(!signCanvas) return;
        const rect = signCanvas.parentElement.getBoundingClientRect();
        signCanvas.width = rect.width; 
        signCanvas.height = 200;
        signCtx = signCanvas.getContext('2d'); 
        signCtx.lineWidth = 3; 
        signCtx.lineCap = 'round'; 
        signCtx.strokeStyle = '#0000ff';
        
        signCanvas.onmousedown=(e)=>{isDrawing=true;draw(e.offsetX,e.offsetY)};
        signCanvas.onmousemove=(e)=>{if(isDrawing)draw(e.offsetX,e.offsetY,true)};
        signCanvas.onmouseup=()=>{isDrawing=false;signCtx.beginPath()};
        signCanvas.ontouchstart=(e)=>{e.preventDefault();const r=signCanvas.getBoundingClientRect();isDrawing=true;draw(e.touches[0].clientX-r.left,e.touches[0].clientY-r.top)};
        signCanvas.ontouchmove=(e)=>{e.preventDefault();if(isDrawing){const r=signCanvas.getBoundingClientRect();draw(e.touches[0].clientX-r.left,e.touches[0].clientY-r.top,true)}};
        signCanvas.ontouchend=()=>{isDrawing=false;signCtx.beginPath()};
    }
    
    function draw(x, y, isLine) { 
        if(isLine){
            signCtx.lineTo(x,y);
            signCtx.stroke();
            signCtx.beginPath();
            signCtx.moveTo(x,y);
        } else {
            signCtx.beginPath();
            signCtx.moveTo(x,y);
        } 
    }
    
    function clearSign() { 
        if(signCtx) signCtx.clearRect(0,0,signCanvas.width,signCanvas.height); 
    }
    
    function updateSignColor() { 
        if(signCtx) signCtx.strokeStyle = document.getElementById('sign-color').value; 
    }
    
    function updateTypedSignature() {
        const text = document.getElementById('typed-signature-input').value || 'Your Signature';
        const font = document.getElementById('signature-font').value;
        const color = document.getElementById('typed-sig-color').value;
        
                
        const preview = document.getElementById('typed-signature-preview');
        if (preview) {
            preview.innerText = text;
            preview.style.fontFamily = font;
            preview.style.color = color;
            
        } 
    }
    
    // Step 1 â†’ Step 2: Save signature and show upload
    function goToStep2() {
        if(signatureMode === 'draw') {
            // Check if canvas has content
            const imageData = signCtx.getImageData(0, 0, signCanvas.width, signCanvas.height);
            const hasContent = imageData.data.some(channel => channel !== 0);
            if(!hasContent) {
                alert('Please draw your signature first!');
                return;
            }
            sigData = signCanvas.toDataURL('image/png');
        } else {
            // Generate typed signature as image
            const text = document.getElementById('typed-signature-input').value.trim();
            if(!text) {
                alert('Please enter your name!');
                return;
            }
            sigData = generateTypedSignatureImage();
        }
        
        document.getElementById('sign-step-1').style.display='none';
        document.getElementById('sign-step-2').style.display='block';
    }
    
    function generateTypedSignatureImage() {
        const text = document.getElementById('typed-signature-input').value;
        const font = document.getElementById('signature-font').value;
        const color = document.getElementById('typed-sig-color').value;
        
        const canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 200;
        const ctx = canvas.getContext('2d');
        
        // Set font
        ctx.font = `80px ${font}`;
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Draw text
        ctx.fillText(text, canvas.width/2, canvas.height/2);
        
        return canvas.toDataURL('image/png');
    }
    
    // Step 2 â†’ Step 1: Go back to signature
    function backToStep1() {
        document.getElementById('sign-step-2').style.display='none';
        document.getElementById('sign-step-3').style.display='none';
        document.getElementById('sign-step-1').style.display='block';
        exitPlaceMode(); // Exit place mode when going back
    }
    
    // Step 2 â†’ Step 3: PDF uploaded, show drag & drop interface
    document.getElementById('in-sign').addEventListener('change', async e => {
        if(!e.target.files[0]) return;
        files.sign = e.target.files[0];
        
        document.getElementById('sign-step-2').style.display='none';
        document.getElementById('sign-step-3').style.display='block';
        
        // Setup signature stamp
        document.getElementById('signature-stamp-img').src = sigData;
        
        // Detect device and setup appropriate interaction
        detectTouchDevice();
        if(isTouchDevice) {
            setupMobileTapMode();
        } else {
            setupDragAndDrop();
        }
        
        await renderPdfForSigning(files.sign);
    });
    
    function updateStampSize(val) {
        currentSigSize = parseInt(val);
        document.getElementById('stamp-size-val').innerText = val + 'px';
        
        // Update floating preview size if in place mode
        const floatingPreview = document.getElementById('floating-sig-preview');
        if(floatingPreview) {
            floatingPreview.style.width = val + 'px';
            floatingPreview.style.height = (val/2) + 'px';
        }
    }

    async function renderPdfForSigning(file) {
        const container = document.getElementById('pdf-sign-container'); 
        container.innerHTML = '';
        
        const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file)).promise;
        
        for(let i=1; i<=pdf.numPages; i++) {
            const div = document.createElement('div'); 
            div.className = 'pdf-page-container'; 
            div.id = `pdf-page-${i}`;
            div.dataset.pageIndex = i-1;
            
            const cvs = document.createElement('canvas'); 
            div.appendChild(cvs); 
            container.appendChild(div);
            
            const page = await pdf.getPage(i); 
            const vp = page.getViewport({scale:1.0});
            cvs.width = vp.width; 
            cvs.height = vp.height;
            await page.render({canvasContext:cvs.getContext('2d'), viewport:vp}).promise;
            
            if(!isTouchDevice) {
                // Desktop: Enable drag & drop
                div.addEventListener('dragover', handleDragOver);
                div.addEventListener('dragleave', handleDragLeave);
                div.addEventListener('drop', handleDrop);
            }
        }
    }
    
    // ========== UNIVERSAL PDF PREVIEW RENDERER ==========
    async function renderPdfPreview(file, containerId) {
        const container = document.getElementById(containerId);
        if(!container) return;
        
        container.innerHTML = '<p style="text-align:center; color:var(--text-muted); padding:20px;">Loading PDF...</p>';
        
        try {
            const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file)).promise;
            container.innerHTML = '';
            
            for(let i = 1; i <= pdf.numPages; i++) {
                const card = document.createElement('div');
                card.className = 'page-card';
                card.style.cursor = 'default';
                
                const canvasWrapper = document.createElement('div');
                canvasWrapper.style.cssText = 'height: 200px; display: flex; align-items: center; justify-content: center; overflow: hidden; padding: 8px; background: #f8f9fa;';
                
                const canvas = document.createElement('canvas');
                canvas.className = 'page-canvas';
                canvasWrapper.appendChild(canvas);
                card.appendChild(canvasWrapper);
                
                const footer = document.createElement('div');
                footer.className = 'page-footer';
                footer.innerHTML = `<span style="font-size: 0.85rem; font-weight: 600;">Page ${i}</span>`;
                card.appendChild(footer);
                
                container.appendChild(card);
                
                // Render PDF page to canvas
                const page = await pdf.getPage(i);
                const viewport = page.getViewport({scale: 1.0});
                
                // Scale to fit in preview
                const scale = Math.min(
                    (canvasWrapper.offsetWidth - 16) / viewport.width,
                    180 / viewport.height
                );
                const scaledViewport = page.getViewport({scale: scale});
                
                canvas.width = scaledViewport.width;
                canvas.height = scaledViewport.height;
                canvas.style.maxWidth = '100%';
                canvas.style.height = 'auto';
                
                await page.render({
                    canvasContext: canvas.getContext('2d'),
                    viewport: scaledViewport
                }).promise;
            }
        } catch(error) {
            console.error('Error rendering PDF preview:', error);
            container.innerHTML = '<p style="text-align:center; color:var(--danger); padding:20px;">Error loading PDF preview</p>';
        }
    }
    
    // ========== MOBILE TAP-TO-PLACE MODE ==========
    let lastTapTime = 0;
    const DOUBLE_TAP_DELAY = 300; // ms
    
    function setupMobileTapMode() {
        const stamp = document.getElementById('signature-stamp');
        const instruction = document.querySelector('.drag-instruction');
        
        // Update instruction text for mobile
        instruction.innerHTML = 'ğŸ‘† Tap to activate';

        // MOBILE FIX: Use both onclick AND touch events for better mobile support
        const activatePlaceMode = (e) => {
            e.preventDefault();
            e.stopPropagation();
            if(!isPlaceMode) {
                enterPlaceMode();
            }
        };
		
	// Remove old listeners first
	stamp.onclick = null;
        stamp.ontouchend = null;
           
        // Add new listeners
	stamp.addEventListener('click', activatePlaceMode);
        stamp.addEventListener('touchend', activatePlaceMode);
		
        // Remove drag attributes on mobile
        stamp.removeAttribute('draggable');
        stamp.style.cursor = 'pointer';
		
	// MOBILE FIX: Ensure stamp is tappable with proper styles
	stamp.style.touchAction = 'manipulation';
	stamp.style.userSelect = 'none';
	stamp.style.webkitUserSelect = 'none';
		
    }
    
    function enterPlaceMode() {
        isPlaceMode = true;
        const stamp = document.getElementById('signature-stamp');
        const instruction = document.querySelector('.drag-instruction');
        
        // Visual feedback
        stamp.style.opacity = '0.5';
        stamp.style.borderColor = '#10b981'; // Green when active
        instruction.innerHTML = '<span style="font-size: 0.95rem;">Move finger to position<br><strong>Double-tap to place</strong></span>';
        instruction.style.background = 'rgba(16, 185, 129, 0.1)';
        instruction.style.borderColor = 'rgba(16, 185, 129, 0.3)';
        
        // Add cancel button
        addCancelButton();
        
        // Create floating preview
        createFloatingPreview();
        
        // Enable tap on PDF pages
        document.querySelectorAll('.pdf-page-container').forEach(page => {
            page.style.cursor = 'crosshair';
            page.addEventListener('touchmove', showPreviewAtTouch);
            page.addEventListener('touchstart', showPreviewAtTouch);
            page.addEventListener('touchend', handleTapForPlacement);
        });
        
        showToast('Move finger to position, double-tap to place');
    }
    
    function exitPlaceMode() {
        isPlaceMode = false;
        const stamp = document.getElementById('signature-stamp');
        const instruction = document.querySelector('.drag-instruction');
        
        // Reset visual feedback
        stamp.style.opacity = '1';
        stamp.style.borderColor = 'var(--primary)';
        instruction.innerHTML = 'ğŸ‘† Tap to activate';
        instruction.style.background = 'rgba(99, 102, 241, 0.1)';
        instruction.style.borderColor = 'rgba(99, 102, 241, 0.3)';
        
        // Remove cancel button
        const cancelBtn = document.getElementById('place-mode-cancel');
        if(cancelBtn) cancelBtn.remove();
        
        // Remove floating preview
        const preview = document.getElementById('floating-sig-preview');
        if(preview) preview.remove();
        
        // Disable tap on PDF pages
        document.querySelectorAll('.pdf-page-container').forEach(page => {
            page.style.cursor = '';
            page.removeEventListener('touchmove', showPreviewAtTouch);
            page.removeEventListener('touchstart', showPreviewAtTouch);
            page.removeEventListener('touchend', handleTapForPlacement);
        });
        
        // Reset double-tap timer
        lastTapTime = 0;
    }
    
    function addCancelButton() {
        // Remove existing if any
        const existing = document.getElementById('place-mode-cancel');
        if(existing) existing.remove();
        
        const cancelBtn = document.createElement('button');
        cancelBtn.id = 'place-mode-cancel';
        cancelBtn.className = 'btn-outline';
        cancelBtn.innerHTML = 'âœ• Cancel';
        cancelBtn.style.cssText = 'margin-top: 12px; width: 100%; background: var(--danger); color: white; border-color: var(--danger);';
        cancelBtn.onclick = () => {
            exitPlaceMode();
            showToast('Placement cancelled');
        };
        
        // Add to signature panel
        const panel = document.querySelector('.signature-panel');
        panel.appendChild(cancelBtn);
    }
    
    function createFloatingPreview() {
        // Remove existing preview if any
        const existing = document.getElementById('floating-sig-preview');
        if(existing) existing.remove();
        
        const preview = document.createElement('div');
        preview.id = 'floating-sig-preview';
        preview.style.cssText = `
            position: fixed;
            width: ${currentSigSize}px;
            height: ${currentSigSize/2}px;
            pointer-events: none;
            z-index: 9999;
            display: none;
            border: 3px dashed #10b981;
            border-radius: 8px;
            background: rgba(16, 185, 129, 0.15);
            opacity: 0.9;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        `;
        
        const img = document.createElement('img');
        img.src = sigData;
        img.style.cssText = 'width: 100%; height: 100%; display: block; opacity: 0.8;';
        preview.appendChild(img);
        
        // Add hint text
        const hint = document.createElement('div');
        hint.style.cssText = `
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(16, 185, 129, 0.9);
            color: white;
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            white-space: nowrap;
            font-weight: 600;
        `;
        hint.textContent = 'Double-tap to place';
        preview.appendChild(hint);
        
        document.body.appendChild(preview);
    }
    
    function showPreviewAtTouch(e) {
        if(!isPlaceMode) return;
        e.preventDefault();
        
        const preview = document.getElementById('floating-sig-preview');
        if(!preview) return;
        
        const touch = e.touches[0];
        preview.style.display = 'block';
        preview.style.left = (touch.clientX - currentSigSize/2) + 'px';
        preview.style.top = (touch.clientY - currentSigSize/4 - 40) + 'px'; // Offset so finger doesn't cover it
    }
    
    function handleTapForPlacement(e) {
        if(!isPlaceMode) return;
        e.preventDefault();
        e.stopPropagation();
        
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTapTime;
        
        // Check if double-tap
        if(tapLength < DOUBLE_TAP_DELAY && tapLength > 0) {
            // DOUBLE TAP - Place signature
            const touch = e.changedTouches[0];
            const pageContainer = e.currentTarget;
            const rect = pageContainer.getBoundingClientRect();
            
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            const pageIdx = parseInt(pageContainer.dataset.pageIndex);
            
            createPlacedSignature(pageContainer, x, y, pageIdx);
            
            showToast('Signature placed! Activate again for more');
            
            // Exit place mode after successful placement
            exitPlaceMode();
            
            // Reset timer
            lastTapTime = 0;
        } else {
            // SINGLE TAP - Just update preview position (already handled by touchmove)
            lastTapTime = currentTime;
        }
    }
    
    // ========== DESKTOP DRAG & DROP ==========
    function setupDragAndDrop() {
        const stamp = document.getElementById('signature-stamp');
        const instruction = document.querySelector('.drag-instruction');
        
        instruction.innerHTML = 'ğŸ‘† Drag to any page';
        stamp.setAttribute('draggable', 'true');
        
        stamp.addEventListener('dragstart', (e) => {
            stamp.style.opacity = '0.5';
            e.dataTransfer.effectAllowed = 'copy';
            
            // Create floating drag preview
            createDragPreview();
            
            // Add document-level dragover to track cursor everywhere
            document.addEventListener('dragover', trackDragPosition);
            
            showToast('Drop signature on any PDF page');
        });
        
        stamp.addEventListener('dragend', (e) => {
            stamp.style.opacity = '1';
            removeDragPreview();
            
            // Remove document-level tracking
            document.removeEventListener('dragover', trackDragPosition);
        });
    }
    
    function trackDragPosition(e) {
        e.preventDefault();
        updateDragPreview(e.clientX, e.clientY);
    }
    
    function createDragPreview() {
        // Remove existing preview
        removeDragPreview();
        
        const preview = document.createElement('div');
        preview.id = 'drag-signature-preview';
        preview.style.cssText = `
            position: fixed;
            width: ${currentSigSize}px;
            height: ${currentSigSize/2}px;
            pointer-events: none;
            z-index: 10000;
            opacity: 0.85;
            border: 3px dashed var(--primary);
            border-radius: 8px;
            background: rgba(99, 102, 241, 0.15);
            display: none;
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.4);
            transition: opacity 0.1s;
        `;
        
        const img = document.createElement('img');
        img.src = sigData;
        img.style.cssText = 'width: 100%; height: 100%; display: block; opacity: 0.9;';
        preview.appendChild(img);
        
        // Add size indicator
        const sizeLabel = document.createElement('div');
        sizeLabel.style.cssText = `
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--primary);
            color: white;
            padding: 3px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            white-space: nowrap;
        `;
        sizeLabel.textContent = currentSigSize + 'px';
        preview.appendChild(sizeLabel);
        
        document.body.appendChild(preview);
    }
    
    function updateDragPreview(x, y) {
        const preview = document.getElementById('drag-signature-preview');
        if(!preview) return;
        
        if(x > 0 && y > 0) {
            preview.style.display = 'block';
            preview.style.left = (x - currentSigSize/2) + 'px';
            preview.style.top = (y - currentSigSize/4) + 'px';
        }
    }
    
    function removeDragPreview() {
        const preview = document.getElementById('drag-signature-preview');
        if(preview) preview.remove();
    }
    
    function handleDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
        e.currentTarget.classList.add('drag-over');
    }
    
    function handleDragLeave(e) {
        if(!e.currentTarget.contains(e.relatedTarget)) {
            e.currentTarget.classList.remove('drag-over');
        }
    }
    
    function handleDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const pageContainer = e.currentTarget;
        pageContainer.classList.remove('drag-over');
        
        const rect = pageContainer.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const pageIdx = parseInt(pageContainer.dataset.pageIndex);
        
        createPlacedSignature(pageContainer, x, y, pageIdx);
    }

    function createPlacedSignature(parent, x, y, pageIdx) {
        const wrapper = document.createElement('div');
        wrapper.className = 'placed-sig';
        wrapper.style.left = (x - currentSigSize/2) + 'px'; 
        wrapper.style.top = (y - currentSigSize/4) + 'px';
        wrapper.style.width = currentSigSize + 'px'; 
        wrapper.style.height = (currentSigSize/2) + 'px';
        
        const img = document.createElement('img'); 
        img.src = sigData;
        wrapper.appendChild(img);
        
        // Add close button
        const closeBtn = document.createElement('div');
        closeBtn.className = 'sig-close-btn';
        closeBtn.innerHTML = 'Ã—';
        closeBtn.onclick = (e) => {
            e.stopPropagation();
            removePlacedSignature(wrapper);
        };
        wrapper.appendChild(closeBtn);
        
        parent.appendChild(wrapper);
        
        const sigObj = { element: wrapper, pageIdx: pageIdx };
        states.placedSigs.push(sigObj);
        
        // Auto-select the newly placed signature
        setTimeout(() => selectSig(wrapper), 50);

        // Interaction
        wrapper.onmousedown = startDragSig; 
        wrapper.ontouchstart = startDragSig;
        wrapper.onclick = (e) => { 
            if(!e.target.classList.contains('sig-close-btn')) {
                e.stopPropagation(); 
                selectSig(wrapper); 
            }
        };
    }
    
    function removePlacedSignature(element) {
        states.placedSigs = states.placedSigs.filter(s => s.element !== element);
        if(states.activeSig === element) {
            states.activeSig = null;
            document.getElementById('sig-toolbar').classList.remove('active');
        }
        element.remove();
        showToast('Signature removed');
    }

    // Logic to Select Signature and Show Bottom Toolbar
    function selectSig(el) {
        document.querySelectorAll('.placed-sig').forEach(s=>s.classList.remove('selected'));
        el.classList.add('selected');
        states.activeSig = el;
        document.getElementById('sig-toolbar').classList.add('active');
        document.getElementById('sig-toolbar-slider').value = parseInt(el.style.width);
        document.getElementById('sig-toolbar-val').innerText = parseInt(el.style.width) + 'px';
    }

    // Toolbar Actions
    window.deleteActiveSig = () => {
        if(states.activeSig) {
            states.placedSigs = states.placedSigs.filter(s => s.element !== states.activeSig);
            states.activeSig.remove();
            states.activeSig = null;
            document.getElementById('sig-toolbar').classList.remove('active');
        }
    };
    
    window.resizeActiveSig = (val) => {
        if(states.activeSig) {
            states.activeSig.style.width = val + 'px';
            states.activeSig.style.height = (val/2) + 'px';
            document.getElementById('sig-toolbar-val').innerText = val + 'px';
        }
    };

    // Drag Logic for Placed Signatures (Touch + Mouse)
    let dragItem = null, startX, startY, origL, origT;
    
    function startDragSig(e) {
        // Don't start drag if clicking close button
        if(e.target.classList.contains('sig-close-btn')) return;
        
        e.preventDefault(); 
        e.stopPropagation();
        selectSig(e.currentTarget);
        dragItem = e.currentTarget;
        dragItem.style.cursor = 'grabbing';
        
        const cx = e.clientX || e.touches[0].clientX; 
        const cy = e.clientY || e.touches[0].clientY;
        startX = cx; 
        startY = cy; 
        origL = parseFloat(dragItem.style.left); 
        origT = parseFloat(dragItem.style.top);
        
        document.addEventListener('mousemove', doDrag); 
        document.addEventListener('touchmove', doDrag, {passive:false});
        document.addEventListener('mouseup', stopDrag); 
        document.addEventListener('touchend', stopDrag);
    }
    
    function doDrag(e) {
        if(!dragItem) return;
        e.preventDefault();
        
        const cx = e.clientX || e.touches[0].clientX; 
        const cy = e.clientY || e.touches[0].clientY;
        
        dragItem.style.left = (origL + cx - startX) + 'px';
        dragItem.style.top = (origT + cy - startY) + 'px';
    }
    
    function stopDrag() {
        if(dragItem) {
            dragItem.style.cursor = 'grab';
        }
        dragItem = null;
        document.removeEventListener('mousemove', doDrag); 
        document.removeEventListener('touchmove', doDrag);
        document.removeEventListener('mouseup', stopDrag);
        document.removeEventListener('touchend', stopDrag);
    }
    
    // Deselect if clicking blank
    window.addEventListener('click', (e) => {
        if(!e.target.closest('.placed-sig') && !e.target.closest('#sig-toolbar')) {
            document.querySelectorAll('.placed-sig').forEach(s=>s.classList.remove('selected'));
            document.getElementById('sig-toolbar').classList.remove('active');
            states.activeSig = null;
        }
    });

    async function burnSignature() {
        if(states.placedSigs.length === 0) return alert("Tap on a page to sign it first!");
        loading(true);
        const pdf = await PDFDocument.load(await files.sign.arrayBuffer());
        const img = await pdf.embedPng(sigData);
        
        states.placedSigs.forEach(item => {
            const page = pdf.getPages()[item.pageIdx];
            const { width, height } = page.getSize();
            
            // FIX: Use ratio-based positioning instead of pixel scaling
            // Get the page container dimensions (visible size on screen)
            const pageContainer = item.element.parentElement;
            const containerWidth = pageContainer.offsetWidth;
            const containerHeight = pageContainer.offsetHeight;
            
            // Get signature position and dimensions from DOM
            const domX = parseFloat(item.element.style.left);
            const domY = parseFloat(item.element.style.top);
            const domW = parseFloat(item.element.style.width);
            const domH = parseFloat(item.element.style.height);
            
            // Calculate position as ratio (0.0 to 1.0) of container dimensions
            const xRatio = domX / containerWidth;
            const yRatio = domY / containerHeight;
            const wRatio = domW / containerWidth;
            const hRatio = domH / containerHeight;
            
            // Apply ratios to actual PDF page dimensions
            const pdfX = xRatio * width;
            const pdfW = wRatio * width;
            const pdfH = hRatio * height;
            // PDF coordinates are bottom-up, so we flip Y
            const pdfY = height - (yRatio * height) - pdfH;
            
            page.drawImage(img, { x: pdfX, y: pdfY, width: pdfW, height: pdfH });
        });
        
        // SHARE IMPLEMENTATION: Store signed PDF globally
        const pdfBytes = await pdf.save();
        window.lastSignedPDF = pdfBytes;
        
        // Show success message and action bar
        loading(false);
        showToast('âœ… PDF signed successfully!');
        showSignActionBar();
    }
    
    // Share signed PDF
    async function shareSignedPDF() {
        if (!window.lastSignedPDF) {
            showToast('âŒ No signed PDF available');
            return;
        }
        
        const blob = new Blob([window.lastSignedPDF], {type: 'application/pdf'});
        const shared = await shareFile(blob, 'signed.pdf');
        
        if (shared) {
            vibrate(HAPTIC.success);
        }
    }
    
    // Download signed PDF
    function downloadSignedPDF() {
        if (!window.lastSignedPDF) {
            showToast('âŒ No signed PDF available');
            return;
        }
        
        download(window.lastSignedPDF, 'signed.pdf');
        vibrate(HAPTIC.success);
    }
    
    // Show/hide sign action bar
    function showSignActionBar() {
        const actionBar = document.getElementById('sign-action-bar');
        if (actionBar) {
            actionBar.style.display = 'flex';
        }
    }
    
    function hideSignActionBar() {
        const actionBar = document.getElementById('sign-action-bar');
        if (actionBar) {
            actionBar.style.display = 'none';
        }
        window.lastSignedPDF = null;
    }

    // ================== OTHER TOOLS (Standard Logic) ==================
    
    // EXTRACT
    document.getElementById('in-extract').addEventListener('change', async e=>{
        if(!e.target.files[0])return; files.extract=e.target.files[0];
        document.querySelector('#tool-extract-text .upload-area').style.display='none';
        document.getElementById('extract-editor').style.display='flex';
        document.getElementById('extract-editor').classList.add('split-layout');
        loading(true, "Processing..."); await renderSelectablePreview(files.extract);
        const pdf=await pdfjsLib.getDocument(URL.createObjectURL(files.extract)).promise;
        let t=""; for(let i=1; i<=pdf.numPages; i++){const p=await pdf.getPage(i);const tc=await p.getTextContent();t+=`--- Page ${i} ---\n${tc.items.map(s=>s.str).join(' ')}\n\n`;}
        document.getElementById('extract-output').value=t; loading(false);
    });
    async function renderSelectablePreview(file) {
        const container = document.getElementById('extract-container'); container.innerHTML='';
        const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file)).promise;
        for(let i=1; i<=pdf.numPages; i++) {
            const w=document.createElement('div'); w.className='text-layer-wrapper';
            const cvs=document.createElement('canvas'); cvs.style.width='100%';
            const tl=document.createElement('div'); tl.className='textLayer';
            w.appendChild(cvs); w.appendChild(tl); container.appendChild(w);
            const page=await pdf.getPage(i); const vp=page.getViewport({scale:1.5});
            cvs.width=vp.width; cvs.height=vp.height;
            tl.style.width=`${vp.width}px`; tl.style.height=`${vp.height}px`; tl.style.setProperty('--scale-factor',1.5);
            await page.render({canvasContext:cvs.getContext('2d'),viewport:vp}).promise;
            const tc=await page.getTextContent(); pdfjsLib.renderTextLayer({textContentSource:tc,container:tl,viewport:vp,textDivs:[]});
        }
    }
    function copyText() { const c=document.getElementById("extract-output"); c.select(); navigator.clipboard.writeText(c.value); showToast("Text Copied"); }
    function downloadText() { const b=new Blob([document.getElementById("extract-output").value],{type:"text/plain"}); download(b,"text.txt"); }

    // WATERMARK
    document.getElementById('in-watermark').addEventListener('change', async e=>{
        if(!e.target.files[0])return; files.watermark=e.target.files[0];
        document.querySelector('#tool-watermark .upload-area').style.display='none';
        document.getElementById('watermark-editor').style.display='flex';
        document.getElementById('watermark-editor').classList.add('split-layout');
        loading(true); await renderStandardPreview(files.watermark, 'watermark-grid', 'watermark'); loading(false);
    });
    async function applyWatermark() {
        loading(true); const pdf=await PDFDocument.load(await files.watermark.arrayBuffer());
        const txt=document.getElementById('wm-text').value; const op=+document.getElementById('wm-opacity').value;
        const sz=+document.getElementById('wm-size').value; const hex=document.getElementById('wm-color').value;
        const r=parseInt(hex.substr(1,2),16)/255; const g=parseInt(hex.substr(3,2),16)/255; const b=parseInt(hex.substr(5,2),16)/255;
        pdf.getPages().forEach(p=>{
            const {width,height}=p.getSize();
            p.drawText(txt,{x:width/2-(txt.length*sz*0.2), y:height/2, size:sz, color:rgb(r,g,b), opacity:op, rotate:degrees(45)});
        });
        download(await pdf.save(), 'watermarked.pdf'); loading(false);
    }

    // ITEM 7: PDF TO IMAGE - Removed (functionality merged into Image & PDF Converter)
    
    // IMAGE COMP
    // ========== IMAGE OPTIMIZER ==========
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // IMAGE OPTIMIZER - PROCESSING STATE MANAGER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let optimizerProcessing = {
        isProcessing: false,
        currentIndex: 0,
        total: 0,
        errors: []
    };
    
    function setOptimizerProcessing(processing, index = 0, total = 0) {
        optimizerProcessing.isProcessing = processing;
        optimizerProcessing.currentIndex = index;
        optimizerProcessing.total = total;
        
        lockOptimizerUI(processing);
        
        if (processing && total > 0) {
            document.getElementById('loader-text').innerText = `Optimizing ${index + 1} of ${total}...`;
        }
    }
    
    function lockOptimizerUI(lock) {
        // Lock preset buttons
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.disabled = lock;
            btn.style.opacity = lock ? '0.5' : '1';
            btn.style.cursor = lock ? 'not-allowed' : 'pointer';
        });
        
        // Lock compression level radios
        document.querySelectorAll('input[name="comp-level"]').forEach(radio => {
            radio.disabled = lock;
            const label = radio.closest('.comp-level-label');
            if (label) {
                label.style.opacity = lock ? '0.5' : '1';
                label.style.cursor = lock ? 'not-allowed' : 'pointer';
            }
        });
        
        // Lock format, resize, preserve text controls
        document.getElementById('comp-format').disabled = lock;
        document.getElementById('comp-resize').disabled = lock;
        document.getElementById('preserve-text').disabled = lock;
        
        // Lock optimize button
        const optimizeBtn = document.getElementById('btn-optimize');
        if (optimizeBtn) {
            optimizeBtn.disabled = lock;
            optimizeBtn.style.opacity = lock ? '0.5' : '1';
            optimizeBtn.style.cursor = lock ? 'not-allowed' : 'pointer';
        }
    }
    
    const IMG_PRESETS = {
        document: { quality: 0.75, resize: 2000, format: 'image/jpeg', preserveText: true },
        photo: { quality: 0.85, resize: 0, format: 'image/jpeg', preserveText: false },
        web: { quality: 0.60, resize: 1280, format: 'image/webp', preserveText: false }
    };
    
    const IMG_LEVELS = {
        high: 0.85,
        balanced: 0.65,
        small: 0.45
    };
    
    let currentImgLevel = 'balanced';
    let totalOriginalSize = 0;
    
    // CRITICAL FIX: Initialize Image Optimizer with clean event listeners
    function initImageOptimizer() {
        const radios = document.querySelectorAll('input[name="comp-level"]');
        radios.forEach(radio => {
            // Clone node to remove ALL existing event listeners (prevents duplicates)
            const newRadio = radio.cloneNode(true);
            radio.parentNode.replaceChild(newRadio, radio);
            
            // CRITICAL FIX: Don't call selectLevel from change event to prevent loop
            // Instead, update state directly
            newRadio.addEventListener('change', function() {
                if(this.checked) {
                    // Update state
                    currentImgLevel = this.value;
                    
                    // Clear preset buttons (manual click)
                    document.querySelectorAll('.preset-btn').forEach(btn => {
                        btn.classList.remove('selected');
                        btn.style.borderColor = 'var(--border)';
                        btn.style.background = 'var(--bg-card)';
                        const title = btn.querySelector('.preset-title');
                        if(title) title.style.color = 'var(--text-main)';
                    });
                    
                    // Update UI
                    updateLevelUI();
                    
                    // Update preview
                    updatePreviewEstimate();
                    
                    console.log('âœ… Radio changed to:', this.value, '| Quality:', IMG_LEVELS[this.value]);
                }
            });
        });
        
        // Initialize UI state
        updateLevelUI();
    }
    
    // Call initialization after DOM is ready
    setTimeout(initImageOptimizer, 100);
    
    // Shared handler for both camera and files inputs
    async function handleOptimizerUpload(files) {
        // PROCESSING LOCK: Prevent uploads during optimization
        if (optimizerProcessing.isProcessing) {
            showToast('âš ï¸ Please wait for current optimization to complete');
            return;
        }
        
        if(!files.length) return;
        
        const rawFiles = Array.from(files);
        
        // ============================================================
        // PHASE 3: AUTO-COMPRESSION FOR IMAGE OPTIMIZER
        // Pre-compress huge files so optimizer doesn't crash
        // ============================================================
        loading(true, 'Processing files...');
        const processedFiles = [];
        
        try {
            for (const file of rawFiles) {
                let processedFile = file;
                
                // Hard limit check (images only)
                if (file.size > 50 * 1024 * 1024) {
                    const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
                    showToast(`âŒ ${file.name} exceeds 50MB limit (${sizeMB}MB)`, 4000);
                    continue; // Skip this file
                }
                
                // Smart processing based on file size
                // CRITICAL: 3MB threshold catches camera photos
                if (file.size > 3 * 1024 * 1024) {
                    // Camera photos & large files: Pre-compress + Fix EXIF
                    const beforeMB = (file.size / (1024 * 1024)).toFixed(1);
                    showToast(`ğŸ“¦ Processing ${file.name} (${beforeMB}MB)...`, 1500);
                    
                    processedFile = await autoCompressLargeImage(file);
                    
                    if (processedFile === null) {
                        continue; // Skip rejected file
                    }
                    
                    if (processedFile.size < beforeMB * 1024 * 1024 * 0.9) {
                        const afterMB = (processedFile.size / (1024 * 1024)).toFixed(1);
                        showToast(`âœ… Reduced to ${afterMB}MB`, 2000);
                    }
                } else {
                    // Very small files (<3MB): Just fix EXIF
                    processedFile = await fixEXIFOnly(file);
                }
                
                processedFiles.push(processedFile);
            }
        } finally {
            loading(false);
        }
        
        if (processedFiles.length === 0) {
            showToast('âš ï¸ No valid files to process');
            e.target.value = '';
            return;
        }
        // ============================================================
        
        const previousCount = states.imgCompFiles.length;
        
        // FEATURE: Append new files instead of replacing
        states.imgCompFiles = [...states.imgCompFiles, ...processedFiles];
        
        // FEATURE: Duplicate detection (by name + size)
        const uniqueFiles = [];
        const seen = new Set();
        
        states.imgCompFiles.forEach(file => {
            const key = `${file.name}-${file.size}`;
            if(!seen.has(key)) {
                seen.add(key);
                uniqueFiles.push(file);
            }
        });
        
        const duplicatesRemoved = states.imgCompFiles.length - uniqueFiles.length;
        states.imgCompFiles = uniqueFiles;
        
        // Check for HEIC files (Priority 2 Feature)
        const heicFiles = states.imgCompFiles.filter(f => f.name.toLowerCase().endsWith('.heic'));
        const heicCount = heicFiles.length;
        
        if(heicCount > 0) {
            document.getElementById('heic-warning').style.display = 'block';
            
            // Filter out HEIC files
            states.imgCompFiles = states.imgCompFiles.filter(f => !f.name.toLowerCase().endsWith('.heic'));
        } else {
            document.getElementById('heic-warning').style.display = 'none';
        }
        
        // Calculate how many were actually added
        const currentCount = states.imgCompFiles.length;
        const addedCount = currentCount - previousCount;
        
        // FEATURE: Smart toast messages
        if(previousCount === 0) {
            // Initial upload
            if(heicCount > 0) {
                showToast(`âœ… ${currentCount} images selected, ${heicCount} HEIC skipped`);
            } else {
                showToast(`âœ… ${currentCount} images selected`);
            }
        } else {
            // Adding more
            let message = '';
            if(addedCount > 0) {
                message = `âœ… ${addedCount} more added`;
            }
            if(duplicatesRemoved > 0) {
                message += `, ${duplicatesRemoved} duplicate${duplicatesRemoved > 1 ? 's' : ''} skipped`;
            }
            if(heicCount > 0) {
                message += `, ${heicCount} HEIC skipped`;
            }
            message += ` (${currentCount} total)`;
            showToast(message);
        }
        
        // FEATURE: Soft warning for large batches
        if(currentCount > 20 && previousCount <= 20) {
            setTimeout(() => {
                showToast('âš ï¸ Processing many images may take time');
            }, 3000);
        }
        
        if(!states.imgCompFiles.length) {
            showToast('âš ï¸ No valid images selected. Please select JPG/PNG.');
            return;
        }
        
        document.querySelectorAll('#tool-img-comp .upload-area').forEach(area => area.parentElement.style.display = 'none');
        document.getElementById('comp-editor').style.display = 'block';
        
        // Calculate total size
        totalOriginalSize = states.imgCompFiles.reduce((sum, f) => sum + f.size, 0);
        
        // FEATURE: Render preview with remove buttons
        renderImagePreviews();
        
        // Clear results
        document.getElementById('comp-results').innerHTML = '';
        
        // Update preview estimate
        updatePreviewEstimate();
    }
    
    // Add event listeners for both inputs
    document.getElementById('in-img-comp-files').addEventListener('change', async e => {
        await handleOptimizerUpload(e.target.files);
        e.target.value = ''; // Reset
    });
    
    document.getElementById('in-img-comp-camera').addEventListener('change', async e => {
        await handleOptimizerUpload(e.target.files);
        e.target.value = ''; // Reset
    });
    
    // Function to add more files to Image Optimizer
    function addMoreOptimizerFiles() {
        // Don't allow adding during processing
        if (optimizerProcessing.isProcessing) {
            showToast('âš ï¸ Please wait for current optimization to complete');
            return;
        }
        
        // Trigger the file input
        const fileInput = document.getElementById('in-img-comp-files');
        if (fileInput) {
            fileInput.click();
        } else {
            console.error('File input not found');
            showToast('âŒ Error: File input not found');
        }
    }
    
    // NEW: Handle Image Optimizer upload button click
    function handleImageOptimizerUploadClick() {
        // Don't allow uploads during processing
        if (optimizerProcessing.isProcessing) {
            showToast('âš ï¸ Please wait for current optimization to complete');
            return;
        }
        
        // Check if mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
        
        if (isMobile) {
            // Mobile: Show modal with options
            openImageOptimizerModal();
        } else {
            // Desktop: Directly open file picker (no camera option)
            document.getElementById('in-img-comp-files').click();
        }
    }
    
    // NEW: Open the upload modal (mobile only)
    function openImageOptimizerModal() {
        const modal = document.getElementById('img-optimizer-upload-modal');
        if (modal) {
            modal.style.display = 'flex';
            vibrate(HAPTIC.light);
        }
    }
    
    // NEW: Close the upload modal
    function closeImageOptimizerModal() {
        const modal = document.getElementById('img-optimizer-upload-modal');
        if (modal) {
            modal.style.display = 'none';
            vibrate(HAPTIC.light);
        }
    }
    
    // NEW: Select files from gallery (mobile)
    function selectImageOptimizerFiles() {
        closeImageOptimizerModal();
        setTimeout(() => {
            document.getElementById('in-img-comp-files').click();
        }, 100);
    }
    
    // NEW: Take photo with camera (mobile)
    function selectImageOptimizerCamera() {
        closeImageOptimizerModal();
        setTimeout(() => {
            document.getElementById('in-img-comp-camera').click();
        }, 100);
    }
    
    // FEATURE: Render image previews with remove buttons
    // Clear All with confirmation for Image Optimizer
    function clearAllOptimizerImages() {
        // PROCESSING LOCK: Prevent clearing during optimization
        if (optimizerProcessing.isProcessing) {
            showToast('âš ï¸ Please wait for optimization to complete');
            return;
        }
        
        if (states.imgCompFiles.length === 0) return;
        
        // SAFETY GUARD: Confirmation dialog
        if (confirm(`Clear all ${states.imgCompFiles.length} images? This cannot be undone.`)) {
            states.imgCompFiles = [];
            optimizerProcessing.errors = [];
            totalOriginalSize = 0;
            
            // Reset UI - show both upload buttons
            document.querySelectorAll('#tool-img-comp .upload-area').forEach(area => area.parentElement.style.display = 'flex');
            document.getElementById('comp-editor').style.display = 'none';
            document.getElementById('comp-results').innerHTML = '';
            
            showToast('ğŸ—‘ï¸ All images cleared');
        }
    }
    
    function renderImagePreviews() {
        const previewGrid = document.getElementById('img-preview-grid');
        previewGrid.innerHTML = '';
        
        // Update count
        document.getElementById('img-count').innerText = states.imgCompFiles.length;
        
        states.imgCompFiles.forEach((file, idx) => {
            const card = document.createElement('div');
            card.className = 'page-card';
            card.style.minHeight = '120px';
            card.style.position = 'relative';
            
            const imgUrl = URL.createObjectURL(file);
            const fileSize = (file.size / 1024).toFixed(1);
            
            const img = new Image();
            img.src = imgUrl;
            img.style.cssText = 'max-width:100%; max-height:100%; object-fit:contain;';
            
            // Priority 1: Revoke URL after load
            img.onload = () => {
                URL.revokeObjectURL(imgUrl);
            };
            
            const imgContainer = document.createElement('div');
            imgContainer.style.cssText = 'height:120px; display:flex; align-items:center; justify-content:center; overflow:hidden; padding:8px; background:#f8f9fa; position:relative;';
            imgContainer.appendChild(img);
            
            // FEATURE: Remove button (positioned over image)
            const removeBtn = document.createElement('button');
            removeBtn.innerHTML = 'âœ•';
            removeBtn.style.cssText = `
                position: absolute;
                top: 4px;
                right: 4px;
                background: var(--danger);
                color: white;
                border-radius: 50%;
                width: 26px;
                height: 26px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 1.1rem;
                font-weight: bold;
                cursor: pointer;
                border: 2px solid white;
                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                z-index: 10;
                transition: all 0.2s;
            `;
            removeBtn.onmouseover = () => {
                removeBtn.style.transform = 'scale(1.1)';
                removeBtn.style.background = '#dc2626';
            };
            removeBtn.onmouseout = () => {
                removeBtn.style.transform = 'scale(1)';
                removeBtn.style.background = 'var(--danger)';
            };
            removeBtn.onclick = (e) => {
                e.stopPropagation();
                removeImage(idx);
            };
            
            imgContainer.appendChild(removeBtn);
            
            const footer = document.createElement('div');
            footer.className = 'page-footer';
            footer.style.fontSize = '0.75rem';
            footer.style.display = 'flex';
            footer.style.justifyContent = 'space-between';
            footer.style.gap = '8px';
            footer.innerHTML = `
                <span style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;" title="${file.name}">${file.name}</span>
                <span style="color:var(--text-muted); font-weight:600; flex-shrink:0;">${fileSize} KB</span>
            `;
            
            card.appendChild(imgContainer);
            card.appendChild(footer);
            previewGrid.appendChild(card);
        });
        
        document.getElementById('img-total-size').innerText = 
            `Total: ${(totalOriginalSize / (1024 * 1024)).toFixed(2)} MB`;
    }
    
    // FEATURE: Remove individual image
    function removeImage(index) {
        const fileName = states.imgCompFiles[index].name;
        
        // Find the preview card element
        const previews = document.querySelectorAll('.img-preview-card');
        const card = previews[index];
        
        if (card) {
            // Add removing class to trigger animation
            card.classList.add('removing');
            
            // Wait for animation to complete, then remove from array
            setTimeout(() => {
                states.imgCompFiles.splice(index, 1);
                
                // Recalculate total size
                totalOriginalSize = states.imgCompFiles.reduce((sum, f) => sum + f.size, 0);
                
                // Re-render
                renderImagePreviews();
                showToast(`ğŸ—‘ï¸ Removed ${fileName}`);
            }, 300); // Match animation duration
        } else {
            // Fallback if element not found
            states.imgCompFiles.splice(index, 1);
            totalOriginalSize = states.imgCompFiles.reduce((sum, f) => sum + f.size, 0);
            renderImagePreviews();
            showToast(`ğŸ—‘ï¸ Removed ${fileName}`);
        }
        
        // Update preview estimate
        updatePreviewEstimate();
        
        // Clear results when files change
        document.getElementById('comp-results').innerHTML = '';
        
        showToast(`ğŸ—‘ï¸ Removed ${fileName}`);
        
        // If no files left, show upload buttons again
        if(states.imgCompFiles.length === 0) {
            document.querySelectorAll('#tool-img-comp .upload-area').forEach(area => area.parentElement.style.display = 'flex');
            document.getElementById('comp-editor').style.display = 'none';
        }
    }
    
    function selectPreset(preset) {
        const config = IMG_PRESETS[preset];
        
        // DOCUMENT FIX: Update preset buttons UI with inline styles for guaranteed visibility
        document.querySelectorAll('.preset-btn').forEach(btn => {
            const isMatch = btn.dataset.preset === preset;
            btn.classList.toggle('selected', isMatch);
            
            // Force inline style update to ensure visual feedback works immediately
            if(isMatch) {
                btn.style.borderColor = 'var(--primary)';
                btn.style.background = 'rgba(99, 102, 241, 0.1)';
                // DOCUMENT FIX: Also update title color explicitly
                const title = btn.querySelector('.preset-title');
                if(title) title.style.color = 'var(--primary)';
            } else {
                btn.style.borderColor = 'var(--border)';
                btn.style.background = 'var(--bg-card)';
                // DOCUMENT FIX: Reset title color
                const title = btn.querySelector('.preset-title');
                if(title) title.style.color = 'var(--text-main)';
            }
        });
        
        // Apply preset settings
        const formatSelect = document.getElementById('comp-format');
        formatSelect.value = config.format;
        
        const resizeSelect = document.getElementById('comp-resize');
        resizeSelect.value = config.resize.toString();
        
        document.getElementById('preserve-text').checked = config.preserveText;
        
        // Set compression level based on preset
        // DOCUMENT FIX: Pass 'true' to tell selectLevel NOT to clear the preset button we just highlighted
        if(preset === 'document') {
            selectLevel('balanced', true);
        } else if(preset === 'photo') {
            selectLevel('high', true);
        } else {
            selectLevel('small', true);
        }
        
        // PRIORITY 2: Update preview estimate
        updatePreviewEstimate();
        
        showToast(`âœ… ${preset.charAt(0).toUpperCase() + preset.slice(1)} preset applied`);
    }
    
    // PRIORITY 2: Preview Estimate Function (DOCUMENT FIX: Simplified level-based calculation)
    function updatePreviewEstimate() {
        if (!states.imgCompFiles?.length || !totalOriginalSize) return;
        
        const resize = +document.getElementById('comp-resize').value;
        const format = document.getElementById('comp-format').value;
        
        // DOCUMENT FIX: Simple level-based reduction estimates
        let reduction = 0;
        if (currentImgLevel === 'high') {
            reduction = 20;
        } else if (currentImgLevel === 'balanced') {
            reduction = 50;
        } else if (currentImgLevel === 'small') {
            reduction = 75;
        }
        
        // Boost reduction if resizing or using WebP
        if (resize > 0) reduction += 15;
        if (format === 'image/webp') reduction += 10;
        
        // Cap at 95%
        reduction = Math.min(reduction, 95);
        
        const estimatedSize = totalOriginalSize * (1 - (reduction / 100));
        
        document.getElementById('optimization-preview').style.display = 'block';
        document.getElementById('preview-before').innerText = 
            (totalOriginalSize / (1024 * 1024)).toFixed(2) + " MB";
        document.getElementById('preview-after').innerText = 
            "~" + (estimatedSize / (1024 * 1024)).toFixed(2) + " MB";
        document.getElementById('preview-reduction').innerText = reduction;
    }
    
    // DOCUMENT FIX: Simplified selectLevel with fromPreset parameter
    function selectLevel(level, fromPreset = false) {
        currentImgLevel = level;
        
        // CRITICAL FIX: Only sync radio when called from preset
        // When called from manual radio click, radio is already checked, so don't touch it
        if (fromPreset) {
            const radio = document.querySelector(`input[name="comp-level"][value="${level}"]`);
            if (radio) {
                radio.checked = true;
            }
        }
        
        // If this was a MANUAL click (not from a preset), clear the preset button highlights
        if (!fromPreset) {
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.classList.remove('selected');
                btn.style.borderColor = 'var(--border)';
                btn.style.background = 'var(--bg-card)';
                const title = btn.querySelector('.preset-title');
                if(title) title.style.color = 'var(--text-main)';
            });
        }
        
        // Update UI
        updateLevelUI();
        
        // Update preview estimate
        updatePreviewEstimate();
        
        console.log('âœ… Level Set:', level, '| Quality:', IMG_LEVELS[level], '| Source:', fromPreset ? 'Preset' : 'Manual');
    }
    
    function updateLevelUI() {
        document.querySelectorAll('.comp-level-label').forEach(label => {
            const radio = label.querySelector('input[name="comp-level"]');
            if(!radio) return;
            
            const isActive = radio.checked;
            label.style.borderColor = isActive ? 'var(--primary)' : 'var(--border)';
            label.style.background = isActive ? 'rgba(99, 102, 241, 0.05)' : 'transparent';
            
            const titleDiv = label.querySelector('div > div:first-child');
            if(titleDiv) {
                titleDiv.style.color = isActive ? 'var(--primary)' : 'var(--text-main)';
            }
        });
    }
    
    // CRITICAL FIX: Global share function for Image Optimizer
    window.shareOptimizedImage = async function(blob, filename) {
        if (!blob) {
            showToast('âŒ No optimized image available');
            return;
        }
        
        const shared = await shareFile(blob, filename);
        
        if (shared) {
            vibrate(HAPTIC.success);
        }
    };
    
    async function runImageOptimization() {
        // PROCESSING LOCK: Prevent double-clicks
        if (optimizerProcessing.isProcessing) {
            showToast('âš ï¸ Optimization already in progress');
            return;
        }
        
        if(!states.imgCompFiles || !states.imgCompFiles.length) {
            showToast('âš ï¸ Please select images first');
            return;
        }
        
        try {
            // SET PROCESSING STATE
            setOptimizerProcessing(true, 0, states.imgCompFiles.length);
            loading(true, 'Starting optimization...');
            
            // Reset errors
            optimizerProcessing.errors = [];
            
            let quality = IMG_LEVELS[currentImgLevel];
            const preserveText = document.getElementById('preserve-text').checked;
            const format = document.getElementById('comp-format').value;
            
            console.log('=== IMAGE OPTIMIZATION START ===');
            console.log('Current Level:', currentImgLevel);
            console.log('Base Quality:', quality);
            console.log('Preserve Text:', preserveText);
            console.log('Format:', format);
            
            // If preserve text is enabled, boost quality
            if (preserveText) {
                quality = Math.max(quality, 0.72);
            }
            
            // PRIORITY 2: WebP quality boost (WebP handles higher compression better)
            if (format === 'image/webp') {
                quality = Math.min(quality + 0.05, 0.95);
            }
            
            const finalQuality = quality;
            
            console.log('Final Quality:', finalQuality);
            console.log('================================');
            
            const resize = +document.getElementById('comp-resize').value;
            const ext = format.split('/')[1].replace('jpeg', 'jpg');
            
            const resultsDiv = document.getElementById('comp-results');
            resultsDiv.innerHTML = '<h4 style="margin-bottom: 16px;">Processing Results</h4>';
            
            let totalCompressedSize = 0;
            let successCount = 0;
            
            for(const [idx, file] of states.imgCompFiles.entries()) {
                // UPDATE GRANULAR PROGRESS
                setOptimizerProcessing(true, idx, states.imgCompFiles.length);
                
                try {
                    const blob = await compressImage(file, finalQuality, resize, format);
                    const savedBytes = file.size - blob.size;
                    const savedPercent = Math.round((savedBytes / file.size) * 100);
                    
                    totalCompressedSize += blob.size;
                    successCount++;
                    
                    // Create result card
                    const resultCard = document.createElement('div');
                resultCard.style.cssText = `
                    background: var(--bg-panel);
                    border: 2px solid var(--border);
                    border-radius: 12px;
                    padding: 16px;
                    margin-bottom: 12px;
                    display: flex;
                    align-items: center;
                    gap: 12px;
                `;
                
                const savedColor = savedPercent > 50 ? '#10b981' : savedPercent > 20 ? '#f59e0b' : '#ef4444';
                
                // SHARE IMPLEMENTATION: Check if share is supported
                const canShareFiles = navigator.share && navigator.canShare;
                const shareBtn = canShareFiles ? `
                    <button class="btn-outline" style="width:auto; margin:0; padding:8px 16px; font-size:0.9rem; border-color:var(--primary); color:var(--primary);" onclick="shareOptimizedImage(this.blob, '${file.name.split('.')[0]}_optimized.${ext}')">
                        ğŸ“¤ Share
                    </button>
                ` : '';
                
                resultCard.innerHTML = `
                    <div style="flex: 1; min-width: 0;">
                        <div style="font-weight: 600; margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${file.name}</div>
                        <div style="font-size: 0.85rem; color: var(--text-muted);">
                            ${(file.size / 1024).toFixed(1)} KB â†’ ${(blob.size / 1024).toFixed(1)} KB
                            <span style="color: ${savedColor}; font-weight: 600; margin-left: 8px;">
                                ${savedPercent > 0 ? '-' + savedPercent : savedPercent}%
                            </span>
                        </div>
                    </div>
                    <div style="display: flex; gap: 8px; flex-shrink: 0;">
                        ${shareBtn}
                        <button class="btn" style="width:auto; margin:0; padding:8px 16px; font-size:0.9rem;" onclick="download(this.blob, '${file.name.split('.')[0]}_optimized.${ext}')">
                            â¬‡ï¸ Save
                        </button>
                    </div>
                `;
                
                // Store blob in both buttons
                const buttons = resultCard.querySelectorAll('button');
                buttons.forEach(btn => btn.blob = blob);
                resultsDiv.appendChild(resultCard);
                
            } catch(error) {
                console.error(`Error processing ${file.name}:`, error);
                optimizerProcessing.errors.push({
                    filename: file.name,
                    reason: error.message || 'Optimization failed'
                });
                showToast(`âš ï¸ Error processing ${file.name}`);
            }
        }
        
        // SHARE IMPLEMENTATION: Share optimized image
        async function shareOptimizedImage(blob, filename) {
            if (!blob) {
                showToast('âŒ No optimized image available');
                return;
            }
            
            const shared = await shareFile(blob, filename);
            
            if (shared) {
                vibrate(HAPTIC.success);
            }
        }
        
        // Show summary
        const totalSaved = totalOriginalSize - totalCompressedSize;
        const totalSavedPercent = Math.round((totalSaved / totalOriginalSize) * 100);
        
        const summaryCard = document.createElement('div');
        summaryCard.style.cssText = `
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(5, 150, 105, 0.05) 100%);
            border: 2px solid #10b981;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            text-align: center;
        `;
        
        let resultMessage = '';
        if(totalSavedPercent >= 50) {
            resultMessage = 'ğŸ‰ <strong>Excellent optimization!</strong>';
        } else if(totalSavedPercent >= 20) {
            resultMessage = 'âœ… <strong>Good optimization!</strong>';
        } else if(totalSavedPercent > 0) {
            resultMessage = 'ğŸ’¡ <strong>Moderate optimization.</strong>';
        } else {
            resultMessage = 'âš ï¸ <strong>Limited optimization possible.</strong>';
            summaryCard.style.background = 'linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(217, 119, 6, 0.05) 100%)';
            summaryCard.style.borderColor = '#f59e0b';
        }
        
        summaryCard.innerHTML = `
            <div style="font-size: 1.5rem; margin-bottom: 12px;">${totalSavedPercent > 0 ? 'âœ¨' : 'â„¹ï¸'}</div>
            <p style="margin: 0 0 12px 0; font-size: 1rem;">${resultMessage}</p>
            <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 16px; align-items: center; margin-bottom: 12px;">
                <div>
                    <div style="font-size: 0.85rem; color: var(--text-muted);">Before</div>
                    <div style="font-size: 1.3rem; font-weight: 700;">${(totalOriginalSize / (1024 * 1024)).toFixed(2)} MB</div>
                </div>
                <div style="font-size: 1.5rem;">â†’</div>
                <div>
                    <div style="font-size: 0.85rem; color: var(--text-muted);">After</div>
                    <div style="font-size: 1.3rem; font-weight: 700; color: #10b981;">${(totalCompressedSize / (1024 * 1024)).toFixed(2)} MB</div>
                </div>
            </div>
            <div style="font-size: 1.4rem; font-weight: 700; color: #10b981;">
                ğŸ“‰ ${totalSavedPercent}% smaller
            </div>
        `;
        
        // Add quality indicators
        const indicators = [];
        if(totalSavedPercent > 50) {
            indicators.push('âœ… Suitable for email');
            indicators.push('âœ… Fast loading');
        } else if(totalSavedPercent > 20) {
            indicators.push('âœ… Good for web');
        }
        
        if(preserveText) {
            indicators.push('âœ… Text clarity preserved');
        }
        
        if(resize > 0) {
            indicators.push('âœ… Resized for web');
        }
        
        if(indicators.length > 0) {
            summaryCard.innerHTML += `
                <div style="margin-top: 16px; padding: 12px; background: rgba(255,255,255,0.5); border-radius: 8px; font-size: 0.85rem; text-align: left;">
                    ${indicators.map(i => `<div style="margin: 4px 0;">${i}</div>`).join('')}
                </div>
            `;
        }
        
        resultsDiv.insertBefore(summaryCard, resultsDiv.firstChild);
        
        // Show error summary if any errors occurred
        if (optimizerProcessing.errors.length > 0) {
            showOptimizerErrorSummary();
            showToast(`âš ï¸ ${successCount} optimized, ${optimizerProcessing.errors.length} failed`);
        } else {
            showToast(`âœ… Optimized ${successCount} images (${totalSavedPercent}% saved)`);
        }
        
        } catch(error) {
            console.error('Optimization error:', error);
            showToast('âŒ Optimization failed. Please try again.');
        } finally {
            // RELEASE PROCESSING LOCK
            setOptimizerProcessing(false);
            loading(false);
        }
    }
    
    // Show error summary after optimization
    function showOptimizerErrorSummary() {
        const resultsDiv = document.getElementById('comp-results');
        const errorsDiv = document.createElement('div');
        errorsDiv.style.cssText = `
            background: rgba(239, 68, 68, 0.1);
            border: 2px solid var(--danger);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        `;
        
        const errorList = optimizerProcessing.errors.map(e => 
            `<li style="margin: 4px 0;"><strong>${e.filename}</strong> - ${e.reason}</li>`
        ).join('');
        
        errorsDiv.innerHTML = `
            <h4 style="margin: 0 0 12px 0; color: var(--danger); font-size: 1rem;">
                âš ï¸ ${optimizerProcessing.errors.length} file(s) failed to optimize:
            </h4>
            <ul style="margin: 0; padding-left: 20px; color: var(--text-main);">
                ${errorList}
            </ul>
        `;
        
        resultsDiv.prepend(errorsDiv);
    }
    
    function compressImage(f, q, w, t) {
        return new Promise((resolve, reject) => {
            const i = new Image();
            const objectUrl = URL.createObjectURL(f);
            i.src = objectUrl;
            
            i.onload = () => {
                // FIX 2: Revoke object URL to prevent memory leak
                URL.revokeObjectURL(objectUrl);
                
                const c = document.createElement('canvas');
                let rw = i.width, rh = i.height;
                
                // FIX 4: Fix resize logic for both portrait and landscape images
                if (w > 0 && (rw > w || rh > w)) {
                    const ratio = Math.min(w / rw, w / rh);
                    rw = Math.floor(rw * ratio);
                    rh = Math.floor(rh * ratio);
                }
                
                c.width = rw;
                c.height = rh;
                c.getContext('2d').drawImage(i, 0, 0, rw, rh);
                
                // FIX 3: Add toBlob safety check
                c.toBlob(blob => {
                    if (!blob) {
                        reject(new Error('Image compression failed'));
                        return;
                    }
                    resolve(blob);
                }, t, q);
            };
            
            i.onerror = () => {
                URL.revokeObjectURL(objectUrl);
                reject(new Error('Image load failed'));
            };
        });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MERGE PDFs - PROCESSING STATE MANAGER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let mergeProcessing = {
        isProcessing: false,
        currentIndex: 0,
        total: 0,
        errors: []
    };
    
    function setMergeProcessing(processing, index = 0, total = 0) {
        mergeProcessing.isProcessing = processing;
        mergeProcessing.currentIndex = index;
        mergeProcessing.total = total;
        
        lockMergeUI(processing);
        
        if (processing && total > 0) {
            document.getElementById('loader-text').innerText = `Merging PDF ${index + 1} of ${total}...`;
        }
    }
    
    function lockMergeUI(lock) {
        // Lock file input
        document.getElementById('in-merge').disabled = lock;
        
        // Lock merge button
        const mergeBtn = document.getElementById('btn-merge');
        if (mergeBtn) {
            mergeBtn.disabled = lock || states.merge.length < 2;
            mergeBtn.style.opacity = lock ? '0.5' : '1';
            mergeBtn.style.cursor = lock ? 'not-allowed' : 'pointer';
        }
        
        // Lock remove buttons
        document.querySelectorAll('#merge-list .icon-btn').forEach(btn => {
            btn.disabled = lock;
            btn.style.opacity = lock ? '0.5' : '1';
            btn.style.cursor = lock ? 'not-allowed' : 'pointer';
        });
        
        // Lock drag and drop
        document.querySelectorAll('#merge-list .file-item').forEach(item => {
            item.draggable = !lock;
            item.style.opacity = lock ? '0.7' : '1';
        });
    }

    // MERGE
    document.getElementById('in-merge').addEventListener('change', e => {
        // PROCESSING LOCK: Prevent uploads during merge
        if (mergeProcessing.isProcessing) {
            showToast('âš ï¸ Please wait for current merge to complete');
            e.target.value = '';
            return;
        }
        
        states.merge = [...states.merge, ...Array.from(e.target.files)]; 
        renderMergeList();
        
        if (e.target.files.length > 0) {
            showToast(`âœ… ${e.target.files.length} PDF${e.target.files.length > 1 ? 's' : ''} added`);
        }
    });
    
    function renderMergeList() {
        const list = document.getElementById('merge-list');
        const controls = document.getElementById('merge-controls');
        const count = document.getElementById('merge-count');
        
        list.innerHTML = '';
        
        // Show/hide controls based on PDF count
        if (states.merge.length > 0) {
            controls.style.display = 'flex';
            count.textContent = states.merge.length;
        } else {
            controls.style.display = 'none';
        }
        
        states.merge.forEach((f, i) => {
            const d = document.createElement('div');
            d.className = 'file-item';
            d.draggable = true;
            d.innerHTML = `<span>${i + 1}. ${f.name}</span><button class="icon-btn" onclick="rmMerge(${i})" style="color:var(--danger)">âœ•</button>`;
            d.ondragstart = e => {
                e.dataTransfer.setData('i', i);
                d.classList.add('dragging');
            };
            d.ondragend = () => d.classList.remove('dragging');
            d.ondragover = e => e.preventDefault();
            d.ondrop = e => {
                e.preventDefault();
                const old = e.dataTransfer.getData('i');
                const it = states.merge.splice(old, 1)[0];
                states.merge.splice(i, 0, it);
                renderMergeList();
            };
            list.appendChild(d);
        });
        
        document.getElementById('btn-merge').disabled = states.merge.length < 2;
    }
    
    // Clear All with confirmation for Merge PDFs
    function clearAllMergePDFs() {
        // PROCESSING LOCK: Prevent clearing during merge
        if (mergeProcessing.isProcessing) {
            showToast('âš ï¸ Please wait for merge to complete');
            return;
        }
        
        if (states.merge.length === 0) return;
        
        // SAFETY GUARD: Confirmation dialog
        if (confirm(`Clear all ${states.merge.length} PDFs? This cannot be undone.`)) {
            states.merge = [];
            mergeProcessing.errors = [];
            renderMergeList();
            showToast('ğŸ—‘ï¸ All PDFs cleared');
        }
    }
    
    window.rmMerge = i => {
        // PROCESSING LOCK: Prevent removal during merge
        if (mergeProcessing.isProcessing) {
            showToast('âš ï¸ Please wait for merge to complete');
            return;
        }
        
        // Find the file-item element
        const items = document.querySelectorAll('#merge-list .file-item');
        const item = items[i];
        
        if (item) {
            // Add removing class to trigger animation
            item.classList.add('removing');
            
            // Wait for animation to complete, then remove from array
            setTimeout(() => {
                states.merge.splice(i, 1);
                renderMergeList();
            }, 300); // Match animation duration
        } else {
            // Fallback if element not found
            states.merge.splice(i, 1);
            renderMergeList();
        }
    };
    
    async function saveMerge() {
        // PROCESSING LOCK: Prevent double-clicks
        if (mergeProcessing.isProcessing) {
            showToast('âš ï¸ Merge already in progress');
            return;
        }
        
        if (states.merge.length < 2) {
            showToast('âš ï¸ Please add at least 2 PDFs to merge');
            return;
        }
        
        try {
            setMergeProcessing(true, 0, states.merge.length);
            loading(true, 'Starting merge...');
            
            const mergedDoc = await PDFDocument.create();
            
            for (let i = 0; i < states.merge.length; i++) {
                const file = states.merge[i];
                
                // UPDATE PROGRESS
                setMergeProcessing(true, i, states.merge.length);
                
                try {
                    const sourceDoc = await PDFDocument.load(await file.arrayBuffer());
                    const copiedPages = await mergedDoc.copyPages(sourceDoc, sourceDoc.getPageIndices());
                    copiedPages.forEach(page => mergedDoc.addPage(page));
                } catch (error) {
                    console.error(`Error merging ${file.name}:`, error);
                    mergeProcessing.errors.push({
                        filename: file.name,
                        reason: error.message || 'Failed to merge PDF'
                    });
                }
            }
            
            const mergedBytes = await mergedDoc.save();
            download(mergedBytes, 'merged.pdf');
            
            if (mergeProcessing.errors.length > 0) {
                showToast(`âš ï¸ Merged with ${mergeProcessing.errors.length} error(s)`);
            } else {
                showToast('âœ… PDFs merged successfully!');
            }
            
        } catch (error) {
            console.error('Merge error:', error);
            showToast('âŒ Merge failed. Please try again.');
        } finally {
            setMergeProcessing(false);
            loading(false);
        }
    }

    // STANDARD PREVIEWER
    async function renderStandardPreview(file, gridId, mode) {
        const grid=document.getElementById(gridId); grid.innerHTML='';
        const pdf=await pdfjsLib.getDocument(URL.createObjectURL(file)).promise;
        const limit = mode==='pdf-img' ? Math.min(10, pdf.numPages) : pdf.numPages;
        for(let i=1; i<=limit; i++){
            const c=document.createElement('div'); c.className='page-card';
            const cvs=document.createElement('canvas'); cvs.className='page-canvas';
            
            if(mode==='split'){
                c.onclick=()=>{if(states.split.has(i)){states.split.delete(i);c.classList.remove('selected')}else{states.split.add(i);c.classList.add('selected')} updateSplitInput()};
                const ft=document.createElement('div'); ft.className='page-footer'; ft.innerText=`Pg ${i}`; c.appendChild(cvs); c.appendChild(ft);
            }
            else if(mode==='rotate'){
                const ft=document.createElement('div'); ft.className='page-footer';
                ft.innerHTML=`<button class="icon-btn" onclick="rotPage(${i-1},-90)">â†º</button> Pg ${i} <button class="icon-btn" onclick="rotPage(${i-1},90)">â†»</button>`;
                cvs.id=`rot-cvs-${i-1}`; c.appendChild(cvs); c.appendChild(ft); states.rotate.set(i-1,0);
            }
            else if(mode==='delete'){
                c.onclick=()=>{if(states.delete.has(i-1)){states.delete.delete(i-1);c.classList.remove('selected')}else{states.delete.add(i-1);c.classList.add('selected')}};
                const ft=document.createElement('div'); ft.className='page-footer'; ft.innerText=`Pg ${i}`; c.appendChild(cvs); c.appendChild(ft);
            }
            else if(mode==='pdf-img' || mode==='watermark'){ c.appendChild(cvs); if(mode==='pdf-img'){ const ft=document.createElement('div'); ft.className='page-footer'; ft.innerHTML=`Pg ${i} <button class="icon-btn" onclick="downloadSinglePage(${i})">â¬‡ï¸</button>`; c.appendChild(ft); } }
            
            c.renderFn=async()=>{const p=await pdf.getPage(i);const vp=p.getViewport({scale:0.25});cvs.width=vp.width;cvs.height=vp.height;await p.render({canvasContext:cvs.getContext('2d'),viewport:vp}).promise};
            grid.appendChild(c); observer.observe(c);
        }
    }

    // OTHER
    document.getElementById('in-split').addEventListener('change', async e=>{ if(!e.target.files[0])return; files.split=e.target.files[0]; document.querySelector('#tool-split .upload-area').style.display='none'; document.getElementById('split-editor').style.display='flex'; document.getElementById('split-editor').classList.add('split-layout'); loading(true); await renderStandardPreview(files.split,'split-grid','split'); loading(false); });
    function updateSplitInput(){ document.getElementById('split-range').value=Array.from(states.split).sort((a,b)=>a-b).join(', '); }
    function syncVisualFromManual(){ const n=new Set(); document.getElementById('split-range').value.split(',').forEach(p=>{ if(p.includes('-')){const[s,e]=p.split('-');if(!isNaN(s))for(let i=+s;i<=+e;i++)n.add(i)}else{if(!isNaN(+p))n.add(+p)} }); states.split=n; document.querySelectorAll('#split-grid .page-card').forEach((c,i)=>{if(n.has(i+1))c.classList.add('selected');else c.classList.remove('selected')}); }
    function selectAllSplit(){ document.querySelectorAll('#split-grid .page-card').forEach((c,i)=>{states.split.add(i+1);c.classList.add('selected')}); updateSplitInput(); }
    function clearSplit(){ states.split.clear(); document.querySelectorAll('#split-grid .page-card').forEach(c=>c.classList.remove('selected')); updateSplitInput(); }
    async function saveSplit(){ if(!states.split.size)return alert("Select pages"); loading(true); const pdf=await PDFDocument.load(await files.split.arrayBuffer()); const d=await PDFDocument.create(); const idx=Array.from(states.split).map(p=>p-1).filter(i=>i>=0&&i<pdf.getPageCount()); (await d.copyPages(pdf,idx)).forEach(p=>d.addPage(p)); download(await d.save(),'split.pdf'); loading(false); }

    document.getElementById('in-rotate').addEventListener('change', async e=>{ if(!e.target.files[0])return; files.rotate=e.target.files[0]; document.querySelector('#tool-rotate .upload-area').style.display='none'; document.getElementById('rotate-editor').style.display='flex'; document.getElementById('rotate-editor').classList.add('split-layout'); loading(true); await renderStandardPreview(files.rotate,'rotate-grid','rotate'); loading(false); });
    window.rotPage=(i,d)=>{const n=(states.rotate.get(i)||0)+d;states.rotate.set(i,n);document.getElementById(`rot-cvs-${i}`).style.transform=`rotate(${n}deg)`};
    window.rotateAll=d=>{states.rotate.forEach((v,k)=>{const n=v+d;states.rotate.set(k,n);document.getElementById(`rot-cvs-${k}`).style.transform=`rotate(${n}deg)`})};
    async function saveRotation(){ loading(true); const pdf=await PDFDocument.load(await files.rotate.arrayBuffer()); const p=pdf.getPages(); states.rotate.forEach((d,i)=>{if(d!==0)p[i].setRotation(degrees(p[i].getRotation().angle+d))}); download(await pdf.save(),'rotated.pdf'); loading(false); }

    document.getElementById('in-delete').addEventListener('change', async e=>{ if(!e.target.files[0])return; files.delete=e.target.files[0]; document.querySelector('#tool-delete .upload-area').style.display='none'; document.getElementById('delete-editor').style.display='block'; loading(true); await renderStandardPreview(files.delete,'delete-grid','delete'); loading(false); });
    async function saveDelete(){ if(!states.delete.size)return alert("Select pages"); loading(true); const pdf=await PDFDocument.load(await files.delete.arrayBuffer()); const k=pdf.getPageIndices().filter(i=>!states.delete.has(i)); const d=await PDFDocument.create(); (await d.copyPages(pdf,k)).forEach(p=>d.addPage(p)); download(await d.save(),'edited.pdf'); loading(false); }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // IMAGE CONVERTER - Complete Implementation
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PROCESSING STATE MANAGER ("The Brain")
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let converterProcessing = {
        isProcessing: false,
        currentIndex: 0,
        total: 0,
        errors: []
    };
    
    function setConverterProcessing(processing, index = 0, total = 0) {
        converterProcessing.isProcessing = processing;
        converterProcessing.currentIndex = index;
        converterProcessing.total = total;
        
        // Lock/unlock UI elements
        lockConverterUI(processing);
        
        // Update progress text in global loader
        if (processing && total > 0) {
            document.getElementById('loader-text').innerText = `Converting ${index + 1} of ${total}...`;
        }
    }
    
    function lockConverterUI(lock) {
        // Disable/enable format dropdowns
        document.querySelectorAll('.output-format-select').forEach(select => {
            select.disabled = lock;
            select.style.opacity = lock ? '0.5' : '1';
            select.style.cursor = lock ? 'not-allowed' : 'pointer';
        });
        
        // Disable/enable remove buttons
        document.querySelectorAll('#img-list .icon-btn').forEach(btn => {
            btn.disabled = lock;
            btn.style.opacity = lock ? '0.5' : '1';
            btn.style.cursor = lock ? 'not-allowed' : 'pointer';
        });
        
        // Disable/enable "Add More Files" button
        const addMoreBtn = document.querySelector('#img-controls .btn-outline');
        if (addMoreBtn) {
            addMoreBtn.disabled = lock;
            addMoreBtn.style.opacity = lock ? '0.5' : '1';
            addMoreBtn.style.cursor = lock ? 'not-allowed' : 'pointer';
        }
        
        // Disable/enable "Convert All" dropdown
        const convertAllDropdown = document.getElementById('convert-all-format');
        if (convertAllDropdown) {
            convertAllDropdown.disabled = lock;
            convertAllDropdown.style.opacity = lock ? '0.5' : '1';
            convertAllDropdown.style.cursor = lock ? 'not-allowed' : 'pointer';
        }
        
        // Disable/enable main Convert button
        const convertBtn = document.querySelector('#img-action-bar .btn');
        if (convertBtn) {
            convertBtn.disabled = lock;
            convertBtn.style.opacity = lock ? '0.5' : '1';
            convertBtn.style.cursor = lock ? 'not-allowed' : 'pointer';
        }
        
        // Disable/enable PDF merge checkbox
        const mergeCheckbox = document.getElementById('merge-pdfs-checkbox');
        if (mergeCheckbox) {
            mergeCheckbox.disabled = lock;
            mergeCheckbox.style.cursor = lock ? 'not-allowed' : 'pointer';
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // HYBRID APPROACH: Smart Button State Management
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Update convert button text and state based on pending files
    function updateConvertButton() {
        const pendingCount = states.images.filter(img => img.status === 'pending').length;
        const convertBtn = document.querySelector('#img-action-bar .btn');
        
        if (!convertBtn) return;
        
        if (pendingCount > 0) {
            // Update button text dynamically
            convertBtn.innerText = `Convert ${pendingCount} Image${pendingCount > 1 ? 's' : ''} â†’`;
            
            // Add visual pulse animation
            convertBtn.classList.add('has-pending-files');
        } else {
            // No pending files - remove pulse
            convertBtn.classList.remove('has-pending-files');
            convertBtn.innerText = 'Convert Images â†’';
        }
    }
    
    // Manage action bar and results visibility based on file states
    function updateConverterUIState() {
        const pendingCount = states.images.filter(img => img.status === 'pending').length;
        const doneCount = states.images.filter(img => img.status === 'done').length;
        
        // Show/hide action bar based on pending files
        if (pendingCount > 0) {
            document.getElementById('img-action-bar').style.display = 'block';
            updateConvertButton();
            
            // SAFETY: Explicitly unlock UI if not processing
            if (!converterProcessing.isProcessing) {
                lockConverterUI(false);
            }
        } else {
            // No pending files - hide action bar
            document.getElementById('img-action-bar').style.display = 'none';
        }
        
        // Show/hide results based on done files
        if (doneCount > 0) {
            document.getElementById('img-results').style.display = 'block';
        } else {
            document.getElementById('img-results').style.display = 'none';
        }
    }
    
    // ================== LIGHTWEIGHT EXIF FIX (NO COMPRESSION) ==================
    // For small images that don't need compression but need orientation fix
    async function fixEXIFOnly(file) {
        try {
            // Just fix orientation, don't resize or compress
            const bitmap = await createImageBitmap(file, {
                imageOrientation: 'from-image'
            });
            
            const canvas = document.createElement('canvas');
            canvas.width = bitmap.width;
            canvas.height = bitmap.height;
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(bitmap, 0, 0);
            bitmap.close();
            
            // Keep original quality (0.95 instead of 0.85)
            const blob = await new Promise(resolve => {
                canvas.toBlob(resolve, file.type || 'image/jpeg', 0.95);
            });
            
            return new File([blob], file.name, {
                type: file.type || 'image/jpeg',
                lastModified: Date.now()
            });
        } catch (err) {
            console.error('EXIF fix error:', err);
            return file; // Fallback to original
        }
    }
    
    // ================== AUTO-COMPRESSION FOR LARGE IMAGES ==================
    // PHASE 3: Prevents browser crashes from huge camera photos (15-50MB)
    // OPTIMIZED: Uses createImageBitmap with imageOrientation flag
    async function autoCompressLargeImage(file) {
        try {
            // HARD LIMIT: Reject files > 50MB (catastrophic failure prevention)
            if (file.size > 50 * 1024 * 1024) {
                const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
                showToast(`âŒ ${file.name} is too large (${sizeMB}MB). Maximum: 50MB`, 4000);
                return null;
            }
            
            // MAGIC FIX: imageOrientation: 'from-image' automatically fixes EXIF rotation!
            // This single flag replaces our entire custom fixImageOrientation() function
            const bitmap = await createImageBitmap(file, { 
                imageOrientation: 'from-image'  // â­ THE HERO FLAG â­
            });
            
            // Calculate new dimensions (max 2048px on longest side)
            let width = bitmap.width;
            let height = bitmap.height;
            const maxDimension = 2048;
            
            if (width > maxDimension || height > maxDimension) {
                if (width > height) {
                    height = Math.round((height / width) * maxDimension);
                    width = maxDimension;
                } else {
                    width = Math.round((width / height) * maxDimension);
                    height = maxDimension;
                }
            }
            
            // Create canvas for resizing
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                bitmap.close();
                throw new Error('Canvas not supported');
            }
            
            // Draw correctly-oriented bitmap to canvas
            ctx.drawImage(bitmap, 0, 0, width, height);
            
            // Clean up bitmap
            bitmap.close();
            
            // Convert to JPEG blob (85% quality = good balance)
            const blob = await new Promise((resolve, reject) => {
                canvas.toBlob(
                    (blob) => {
                        if (blob) {
                            resolve(blob);
                        } else {
                            reject(new Error('Failed to create compressed image'));
                        }
                    },
                    'image/jpeg',
                    0.85
                );
            });
            
            // Create new File object with compressed data
            const compressedFile = new File(
                [blob], 
                file.name.replace(/\.\w+$/, '.jpg'),
                { type: 'image/jpeg', lastModified: Date.now() }
            );
            
            return compressedFile;
            
        } catch (err) {
            console.error('Auto-compression error:', err.message);
            
            // GRACEFUL DEGRADATION: Handle failures based on severity
            
            // HARD LIMIT REJECTION: File too dangerous
            if (file.size > 50 * 1024 * 1024) {
                return null; // Already showed toast above
            }
            
            // SOFT FAILURE: Compression failed, but file is safe size
            showToast(`âš ï¸ Could not optimize ${file.name}. Using original file.`, 3000);
            return file; // Return original file (risky but allows workflow)
        }
    }
    
    // Upload handler with 10-image limit and duplicate detection
    document.getElementById('in-imgs').addEventListener('change', async e => { 
        // PROCESSING LOCK: Prevent uploads during conversion
        if (converterProcessing.isProcessing) {
            showToast('âš ï¸ Please wait for current conversion to complete');
            e.target.value = '';
            return;
        }
        
        const rawFiles = Array.from(e.target.files);
        
        if(rawFiles.length === 0) return;
        
        // HYBRID: Validate images AND PDFs
        const validFiles = rawFiles.filter(f => 
            f.type.startsWith('image/') || f.type === 'application/pdf'
        );
        
        if(validFiles.length === 0) {
            showToast('âš ï¸ Please select valid image or PDF files');
            return;
        }
        
        // Filter out HEIC files
        const heicFiles = validFiles.filter(f => f.name.toLowerCase().endsWith('.heic'));
        const nonHeicFiles = validFiles.filter(f => !f.name.toLowerCase().endsWith('.heic'));
        
        if(nonHeicFiles.length === 0) {
            showToast('âš ï¸ HEIC files not supported. Please convert to JPG first.');
            return;
        }
        
        const previousCount = states.images.length;
        
        // Check 10-file limit BEFORE processing
        if(previousCount + nonHeicFiles.length > 10) {
            showToast('âš ï¸ Maximum 10 files at once. Please select fewer files.');
            return;
        }
        
        loading(true, 'Processing files...');
        
        const newImages = [];
        
        try {
            for (const file of nonHeicFiles) {
                
                // ============================================================
                // PHASE 3: FIX CAMERA PHOTO ORIENTATION (EXIF)
                // Mobile photos are often rotated/mirrored - fix this first
                // ============================================================
                let processedFile = file;
                
                if (file.type.startsWith('image/')) {
                    // ============================================================
                    // PHASE 3: SMART PROCESSING WITH MEMORY SAFETY
                    // Camera photos (>3MB): Always compress (prevents memory errors)
                    // Small files (<3MB): Just fix EXIF (lightweight)
                    // Large files (>10MB): Full compression
                    // ============================================================
                    
                    // CRITICAL: Lower threshold to 3MB to catch camera photos
                    // Modern phone cameras produce 5-15MB images which cause memory errors
                    if (file.size > 3 * 1024 * 1024) {
                        const beforeMB = (file.size / (1024 * 1024)).toFixed(1);
                        
                        // Transparent feedback to user
                        showToast(`ğŸ“¦ Processing ${file.name} (${beforeMB}MB)...`, 1500);
                        
                        // Compress + Fix EXIF (prevents memory errors)
                        processedFile = await autoCompressLargeImage(file);
                        
                        // Handle compression results
                        if (processedFile === null) {
                            // File was rejected (>50MB hard limit)
                            continue; // Skip this file, move to next
                        }
                        
                        const afterMB = (processedFile.size / (1024 * 1024)).toFixed(1);
                        if (file.size > 10 * 1024 * 1024) {
                            // Show savings for large files
                            const saved = Math.round((1 - processedFile.size/file.size) * 100);
                            showToast(`âœ… ${beforeMB}MB â†’ ${afterMB}MB (${saved}% saved)`, 2000);
                        }
                    } else {
                        // Very small file (<3MB) - just fix EXIF orientation
                        processedFile = await fixEXIFOnly(file);
                    }
                }
                // ============================================================
                
                // BRANCH 1: IT IS A PDF
                if (processedFile.type === 'application/pdf') {
                    try {
                        loading(true, `Analyzing ${processedFile.name}...`);
                        
                        // Get page count FIRST
                        const pdf = await pdfjsLib.getDocument(URL.createObjectURL(processedFile)).promise;
                        const pageCount = pdf.numPages;
                        
                        // SAFETY LIMIT: Block > 300 pages
                        if (pageCount > 300) {
                            showSplitPDFGuidance(processedFile.name, pageCount);
                            continue; // Skip this file
                        }
                        
                        // SMART DECISION: Auto-extract small PDFs
                        if (pageCount <= 10) {
                            loading(true, `Extracting ${pageCount} pages from ${processedFile.name}...`);
                            const pdfImages = await extractPDFPages(processedFile, pdf);
                            newImages.push(...pdfImages);
                            
                        } else {
                            // Large PDF (11-300 pages) - keep as single item with page-range option
                            if (pageCount > 100) {
                                // Show warning for very large PDFs
                                showLargePDFWarning(processedFile.name, pageCount);
                            }
                            
                            newImages.push({
                                file: processedFile,
                                isPDF: true,
                                pageCount: pageCount,
                                pdfDocument: pdf, // Keep PDF loaded for later extraction
                                pageRangeStart: 1,
                                pageRangeEnd: Math.min(50, pageCount), // Default: first 50 pages
                                pageRangeMode: 'custom', // 'all' or 'custom'
                                rot: 0,
                                outputFormat: 'jpg', // Default output for PDFs
                                status: 'pending',
                                convertedBlob: null,
                                originalSize: processedFile.size,
                                convertedSize: 0,
                                width: 0,
                                height: 0
                            });
                        }
                        
                    } catch (error) {
                        console.error('PDF error:', error);
                        showToast(`âŒ Unable to read ${processedFile.name}: ${error.message}`);
                        continue; // Skip this file
                    }
                    
                } 
                // BRANCH 2: IT IS AN IMAGE
                else {
                    // Get image dimensions (using potentially compressed file)
                    const dimensions = await getImageDimensions(processedFile);
                    
                    newImages.push({
                        file: processedFile, // Uses optimized file!
                        isPDF: false, 
                        rot: 0,
                        outputFormat: getDefaultFormat(processedFile),
                        status: 'pending',
                        convertedBlob: null,
                        originalSize: processedFile.size,
                        convertedSize: 0,
                        width: dimensions.width,
                        height: dimensions.height
                    });
                }
            }
            
            // Append to existing
            states.images = [...states.images, ...newImages];
            
            // Duplicate detection (by name + size)
            const uniqueImages = [];
            const seen = new Set();
            states.images.forEach(img => {
                const key = `${img.file.name}-${img.file.size}`;
                if(!seen.has(key)) {
                    seen.add(key);
                    uniqueImages.push(img);
                }
            });
            
            const duplicatesRemoved = states.images.length - uniqueImages.length;
            states.images = uniqueImages;
            
            // Show feedback
            const currentCount = states.images.length;
            const addedCount = currentCount - previousCount;
            
            if(previousCount === 0) {
                let message = `âœ… ${currentCount} file${currentCount > 1 ? 's' : ''} added`;
                if(heicFiles.length > 0) {
                    message += `, ${heicFiles.length} HEIC skipped`;
                }
                showToast(message);
            } else {
                let message = `âœ… ${addedCount} more added`;
                if(duplicatesRemoved > 0) {
                    message += `, ${duplicatesRemoved} duplicate${duplicatesRemoved > 1 ? 's' : ''} skipped`;
                }
                if(heicFiles.length > 0) {
                    message += `, ${heicFiles.length} HEIC skipped`;
                }
                message += ` (${currentCount} total)`;
                showToast(message);
            }
            
            document.getElementById('img-controls').style.display = 'block'; 
            document.querySelector('#tool-images .upload-area').style.display = 'none';
            renderImgList();
            
            // HYBRID APPROACH: Update UI state (action bar, results, button text)
            updateConverterUIState();
            
        } catch (error) {
            console.error("Import error:", error);
            showToast("âŒ Error processing files: " + error.message);
        } finally {
            loading(false);
            e.target.value = '';
        }
    });
    
    // Get default output format based on input
    function getDefaultFormat(file) {
        if(file.type === 'image/jpeg' || file.type === 'image/jpg') return 'jpg';
        if(file.type === 'image/png') return 'png';
        if(file.type === 'image/webp') return 'webp';
        if(file.type === 'application/pdf') return 'jpg'; // PDFs default to JPG
        return 'jpg'; // Fallback
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PDF EXTRACTION & GUIDANCE FUNCTIONS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Extract PDF pages to images (for small PDFs â‰¤ 10 pages)
    async function extractPDFPages(pdfFile, pdfDocument) {
        const pages = [];
        const baseName = pdfFile.name.replace('.pdf', '');
        
        for (let i = 1; i <= pdfDocument.numPages; i++) {
            const page = await pdfDocument.getPage(i);
            const viewport = page.getViewport({ scale: 2.0 }); // 2x for quality
            
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            
            await page.render({
                canvasContext: context,
                viewport: viewport
            }).promise;
            
            const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
            const fileName = `${baseName}_page${i}.png`;
            const imageFile = new File([blob], fileName, { type: 'image/png' });
            
            pages.push({
                file: imageFile,
                isPDF: false, // Now it's an image
                rot: 0,
                outputFormat: 'jpg', // Default output
                status: 'pending',
                convertedBlob: null,
                originalSize: blob.size,
                convertedSize: 0,
                width: viewport.width,
                height: viewport.height
            });
        }
        
        return pages;
    }
    
    // Extract specific page range from PDF (for conversion with page selection)
    async function extractPDFPageRange(pdfDocument, startPage, endPage, baseName, outputFormat) {
        const images = [];
        baseName = baseName.replace('.pdf', '');
        const totalPages = endPage - startPage + 1;
        
        for (let i = startPage; i <= endPage; i++) {
            loading(true, `Extracting page ${i - startPage + 1} of ${totalPages}...`);
            
            const page = await pdfDocument.getPage(i);
            const viewport = page.getViewport({ scale: 2.0 }); // 2x for quality
            
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            
            await page.render({
                canvasContext: context,
                viewport: viewport
            }).promise;
            
            // Convert to desired format
            const mimeType = `image/${outputFormat === 'jpg' ? 'jpeg' : outputFormat}`;
            const quality = outputFormat === 'jpg' ? 0.92 : undefined;
            
            const blob = await new Promise(resolve => {
                if (quality !== undefined) {
                    canvas.toBlob(resolve, mimeType, quality);
                } else {
                    canvas.toBlob(resolve, mimeType);
                }
            });
            
            images.push({
                name: `${baseName}_page${i}.${outputFormat}`,
                blob: blob
            });
        }
        
        return images;
    }
    
    // Download multiple files as ZIP
    async function downloadAsZIP(files, zipName) {
        loading(true, 'Creating ZIP file...');
        
        const zip = new JSZip();
        
        // Add each file to ZIP
        files.forEach(file => {
            zip.file(file.name, file.blob);
        });
        
        // Generate ZIP
        const zipBlob = await zip.generateAsync({ 
            type: 'blob',
            compression: 'DEFLATE',
            compressionOptions: { level: 6 }
        });
        
        // Download
        const link = document.createElement('a');
        link.href = URL.createObjectURL(zipBlob);
        link.download = `${zipName}.zip`;
        link.click();
        URL.revokeObjectURL(link.href);
    }
    
    // Show Split PDF guidance for PDFs > 300 pages
    function showSplitPDFGuidance(fileName, pageCount) {
        const message = `
            <div style="text-align: left; line-height: 1.6;">
                <strong style="color: var(--danger); font-size: 1.1rem;">âŒ PDF too large (${pageCount} pages)</strong><br><br>
                
                PDFs larger than 300 pages cannot be converted directly due to browser limitations.<br><br>
                
                <strong style="color: var(--primary);">âœ… Solution:</strong><br>
                1. Use <strong>Split PDF</strong> to divide into smaller parts<br>
                2. Return here to convert each part separately<br><br>
                
                Recommended: 100-200 pages per section<br><br>
                
                <button onclick="nav('split'); document.getElementById('custom-modal').style.display='none';" 
                        style="background: var(--primary); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1rem;">
                    â†’ Go to Split PDF Tool
                </button>
            </div>
        `;
        
        showCustomModal('Large PDF Detected', message);
    }
    
    // Show warning for large PDFs (101-300 pages)
    function showLargePDFWarning(fileName, pageCount) {
        const message = `
            <div style="text-align: left; line-height: 1.6;">
                <strong style="color: #f59e0b; font-size: 1.1rem;">âš ï¸ Large PDF detected (${pageCount} pages)</strong><br><br>
                
                <strong style="color: var(--primary);">ğŸ’¡ Recommended Workflow:</strong><br><br>
                
                <strong>Option 1 (Faster):</strong><br>
                1. Use <strong>Split PDF</strong> to divide into sections<br>
                2. Convert each section separately<br><br>
                
                <button onclick="nav('split'); document.getElementById('custom-modal').style.display='none';" 
                        style="background: var(--primary); color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; margin-bottom: 16px;">
                    â†’ Go to Split PDF Tool
                </button><br><br>
                
                <strong>Option 2 (Convert directly):</strong><br>
                You can convert page ranges below.<br>
                Default: Pages 1-50 (you can adjust)<br><br>
                
                <button onclick="document.getElementById('custom-modal').style.display='none';" 
                        style="background: var(--bg-panel); color: var(--text-main); border: 2px solid var(--border); padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: 600;">
                    Continue with Page Range
                </button>
            </div>
        `;
        
        showCustomModal('Large PDF - Recommendation', message);
    }
    
    // Custom modal for guidance (reusable)
    function showCustomModal(title, htmlContent) {
        // Create modal if doesn't exist
        let modal = document.getElementById('custom-modal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'custom-modal';
            modal.style.cssText = `
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                padding: 20px;
            `;
            modal.innerHTML = `
                <div style="background: var(--bg-card); padding: 32px; border-radius: 16px; max-width: 600px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
                    <h3 id="modal-title" style="margin: 0 0 20px 0; font-size: 1.4rem; color: var(--text-main);"></h3>
                    <div id="modal-content"></div>
                    <button onclick="document.getElementById('custom-modal').style.display='none';" 
                            style="position: absolute; top: 16px; right: 16px; background: transparent; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text-muted); padding: 4px 8px;">
                        âœ•
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Close on backdrop click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            });
        }
        
        modal.querySelector('#modal-title').innerText = title;
        modal.querySelector('#modal-content').innerHTML = htmlContent;
        modal.style.display = 'flex';
    }
    
    // Get image dimensions (for resolution display)
    async function getImageDimensions(file) {
        return new Promise((resolve) => {
            const img = new Image();
            const url = URL.createObjectURL(file);
            img.onload = () => {
                URL.revokeObjectURL(url);
                resolve({ width: img.width, height: img.height });
            };
            img.onerror = () => {
                URL.revokeObjectURL(url);
                resolve({ width: 0, height: 0 });
            };
            img.src = url;
        });
    }
    
    // Render image list with new design
    function renderImgList() { 
        const list = document.getElementById('img-list'); 
        list.innerHTML = ''; 
        
        // Update counts
        const count = states.images.length;
        document.getElementById('img-count').innerText = count;
        document.getElementById('img-count-bar').innerText = count;
        
        if(count === 0) {
            document.getElementById('img-controls').style.display = 'none';
            document.querySelector('#tool-images .upload-area').style.display = 'flex';
            document.getElementById('img-results').style.display = 'none';
            return;
        }
        
        states.images.forEach((item, i) => {
            const row = document.createElement('div');
            row.className = 'image-converter-row';
            
            // Add staggered animation delay
            row.style.animationDelay = `${i * 50}ms`;
            
            row.style.cssText = `
                background: var(--bg-card);
                border: 2px solid var(--border);
                border-radius: 12px;
                padding: 16px;
                margin-bottom: 12px;
                display: flex;
                gap: 16px;
                align-items: center;
                flex-wrap: wrap;
                animation: rowFadeIn 0.3s cubic-bezier(0.4, 0, 0.2, 1) backwards;
                animation-delay: ${i * 50}ms;
            `;
            
            // BRANCH: PDF vs IMAGE rendering
            if (item.isPDF) {
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // PDF ITEM RENDERING (with page-range selector)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // PDF Icon (instead of thumbnail)
                const pdfIcon = document.createElement('div');
                pdfIcon.style.cssText = `
                    width: 80px;
                    height: 80px;
                    border-radius: 8px;
                    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
                    flex-shrink: 0;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    color: white;
                    font-weight: bold;
                `;
                pdfIcon.innerHTML = `
                    <div style="font-size: 2rem;">ğŸ“•</div>
                    <div style="font-size: 0.7rem; margin-top: 4px;">${item.pageCount} pages</div>
                `;
                
                // Info section
                const info = document.createElement('div');
                info.className = 'pdf-info';
                info.style.cssText = 'flex: 1; min-width: 250px;';
                
                const sizeInMB = (item.file.size / (1024*1024)).toFixed(2);
                
                info.innerHTML = `
                    <div style="font-weight: 600; font-size: 0.95rem; margin-bottom: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${item.file.name}">
                        ğŸ“„ ${item.file.name}
                    </div>
                    <div style="color: var(--text-muted); font-size: 0.85rem; margin-bottom: 12px;">
                        ${sizeInMB} MB â€¢ ${item.pageCount} pages
                    </div>
                    
                    <!-- PAGE RANGE SELECTOR -->
                    <div style="background: var(--bg-panel); padding: 12px; border-radius: 8px; border: 1px solid var(--border);">
                        <div style="font-size: 0.85rem; color: var(--text-muted); font-weight: 600; margin-bottom: 8px;">Pages to convert:</div>
                        
                        <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                            <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                                <input type="radio" name="range-mode-${i}" value="all" ${item.pageRangeMode === 'all' ? 'checked' : ''} 
                                       onchange="updatePageRangeMode(${i}, 'all')" 
                                       style="cursor: pointer;">
                                <span style="font-size: 0.85rem;">All (${item.pageCount})</span>
                            </label>
                            
                            <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                                <input type="radio" name="range-mode-${i}" value="custom" ${item.pageRangeMode === 'custom' ? 'checked' : ''} 
                                       onchange="updatePageRangeMode(${i}, 'custom')"
                                       style="cursor: pointer;">
                                <span style="font-size: 0.85rem;">Custom:</span>
                            </label>
                            
                            <input type="number" min="1" max="${item.pageCount}" value="${item.pageRangeStart}" 
                                   id="range-start-${i}"
                                   onchange="updatePageRange(${i})"
                                   ${item.pageRangeMode === 'all' ? 'disabled' : ''}
                                   style="width: 70px; padding: 6px 8px; border: 1px solid var(--border); border-radius: 4px; font-size: 0.85rem; background: var(--bg-card);">
                            
                            <span style="color: var(--text-muted); font-size: 0.85rem;">to</span>
                            
                            <input type="number" min="1" max="${item.pageCount}" value="${item.pageRangeEnd}" 
                                   id="range-end-${i}"
                                   onchange="updatePageRange(${i})"
                                   ${item.pageRangeMode === 'all' ? 'disabled' : ''}
                                   style="width: 70px; padding: 6px 8px; border: 1px solid var(--border); border-radius: 4px; font-size: 0.85rem; background: var(--bg-card);">
                        </div>
                        
                        ${item.pageCount > 100 ? `
                            <div style="margin-top: 8px; font-size: 0.75rem; color: var(--text-muted);">
                                ğŸ’¡ Tip: Convert in batches for better performance
                            </div>
                        ` : ''}
                    </div>
                `;
                
                // Output selector
                const outputSection = document.createElement('div');
                outputSection.className = 'output-section';
                outputSection.style.cssText = 'display: flex; flex-direction: column; gap: 8px; min-width: 140px;';
                outputSection.innerHTML = `
                    <label style="font-size: 0.85rem; color: var(--text-muted); font-weight: 600;">Output:</label>
                    <select class="output-format-select" data-index="${i}" style="padding: 10px; font-size: 16px; border-radius: 8px; border: 2px solid var(--border); background: var(--bg-panel);">
                        <option value="jpg" ${item.outputFormat === 'jpg' ? 'selected' : ''}>JPG</option>
                        <option value="png" ${item.outputFormat === 'png' ? 'selected' : ''}>PNG</option>
                        <option value="webp" ${item.outputFormat === 'webp' ? 'selected' : ''}>WebP</option>
                    </select>
                `;
                
                // Status
                const status = document.createElement('div');
                status.className = 'status-section';
                status.style.cssText = 'min-width: 100px; text-align: center;';
                status.innerHTML = `<div class="status-badge status-pending"><span class="status-icon">â³</span><span class="status-text">Pending</span></div>`;
                
                // Remove button
                const removeBtn = document.createElement('button');
                removeBtn.className = 'icon-btn';
                removeBtn.innerHTML = 'âœ•';
                removeBtn.style.cssText = 'color: var(--danger); font-size: 1.3rem; width: 36px; height: 36px;';
                removeBtn.onclick = () => rmImg(i);
                
                row.appendChild(pdfIcon);
                row.appendChild(info);
                row.appendChild(outputSection);
                row.appendChild(status);
                row.appendChild(removeBtn);
                
            } else {
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // IMAGE ITEM RENDERING (original logic)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // Thumbnail
                const imgUrl = URL.createObjectURL(item.file);
                const thumb = document.createElement('div');
                thumb.style.cssText = `
                    width: 80px;
                    height: 80px;
                    border-radius: 8px;
                    overflow: hidden;
                    background: #f8f9fa;
                    flex-shrink: 0;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    cursor: pointer;
                `;
                thumb.innerHTML = `<img src="${imgUrl}" style="max-width:100%; max-height:100%; object-fit:contain; transform:rotate(${item.rot}deg); transition:0.3s;">`;
                thumb.onclick = () => rImg(i, 90);
                
                // Clean up URL after load
                thumb.querySelector('img').onload = () => URL.revokeObjectURL(imgUrl);
                
                // Info section
                const info = document.createElement('div');
                info.className = 'image-info';
                info.style.cssText = 'flex: 1; min-width: 200px;';
                
                const sizeInMB = (item.file.size / (1024*1024)).toFixed(2);
                const resolution = item.width > 0 ? `${item.width}Ã—${item.height}` : 'Unknown';
                
                info.innerHTML = `
                    <div style="font-weight: 600; font-size: 0.95rem; margin-bottom: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${item.file.name}">
                        ${item.file.name}
                    </div>
                    <div style="color: var(--text-muted); font-size: 0.85rem;">
                        ${sizeInMB} MB â€¢ ${resolution}
                    </div>
                `;
                
                // Output selector
                const outputSection = document.createElement('div');
                outputSection.className = 'output-section';
                outputSection.style.cssText = 'display: flex; flex-direction: column; gap: 8px; min-width: 160px;';
                outputSection.innerHTML = `
                    <label style="font-size: 0.85rem; color: var(--text-muted); font-weight: 600;">Output:</label>
                    <select class="output-format-select" data-index="${i}" style="padding: 10px; font-size: 16px; border-radius: 8px; border: 2px solid var(--border); background: var(--bg-panel);">
                        <option value="jpg" ${item.outputFormat === 'jpg' ? 'selected' : ''}>JPG</option>
                        <option value="png" ${item.outputFormat === 'png' ? 'selected' : ''}>PNG</option>
                        <option value="webp" ${item.outputFormat === 'webp' ? 'selected' : ''}>WebP</option>
                        <option value="pdf" ${item.outputFormat === 'pdf' ? 'selected' : ''}>PDF</option>
                    </select>
                `;
                
                // Status badge
                const status = document.createElement('div');
                status.className = 'status-section';
                status.style.cssText = 'min-width: 120px; text-align: center;';
                
                let statusHTML = '';
                if(item.status === 'pending') {
                    statusHTML = `<div class="status-badge status-pending"><span class="status-icon">â³</span><span class="status-text">Pending</span></div>`;
                } else if(item.status === 'converting') {
                    statusHTML = `<div class="status-badge status-converting"><span class="status-icon">âš™ï¸</span><span class="status-text">Converting...</span></div>`;
                } else if(item.status === 'done') {
                    const savedMB = ((item.originalSize - item.convertedSize) / (1024*1024)).toFixed(2);
                    const savedPercent = Math.round((1 - item.convertedSize / item.originalSize) * 100);
                    statusHTML = `
                        <div class="status-badge status-done"><span class="status-icon">âœ“</span><span class="status-text">Done</span></div>
                        <div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 4px;">Saved ${savedPercent}%</div>
                    `;
                } else if(item.status === 'merged') {
                    statusHTML = `<div class="status-badge status-merged"><span class="status-icon">ğŸ“‘</span><span class="status-text">Merged</span></div>`;
                } else if(item.status === 'error') {
                    statusHTML = `<div class="status-badge status-error"><span class="status-icon">âš ï¸</span><span class="status-text">Error</span></div>`;
                }
                
                status.innerHTML = statusHTML;
                
                // Remove button
                const removeBtn = document.createElement('button');
                removeBtn.className = 'icon-btn';
                removeBtn.innerHTML = 'âœ•';
                removeBtn.style.cssText = 'color: var(--danger); font-size: 1.3rem; width: 36px; height: 36px;';
                removeBtn.onclick = () => rmImg(i);
                
                row.appendChild(thumb);
                row.appendChild(info);
                row.appendChild(outputSection);
                row.appendChild(status);
                row.appendChild(removeBtn);
            }
            
            list.appendChild(row);
        });
        
        // Add change listeners to dropdowns
        document.querySelectorAll('.output-format-select').forEach(select => {
            select.addEventListener('change', function() {
                const index = parseInt(this.dataset.index);
                states.images[index].outputFormat = this.value;
                updatePDFMergeVisibility();
            });
        });
        
        updatePDFMergeVisibility();
    }
    
    // Update page-range mode (all vs custom)
    function updatePageRangeMode(index, mode) {
        states.images[index].pageRangeMode = mode;
        
        // Enable/disable inputs
        document.getElementById(`range-start-${index}`).disabled = (mode === 'all');
        document.getElementById(`range-end-${index}`).disabled = (mode === 'all');
        
        // If switching to 'all', reset to full range
        if (mode === 'all') {
            states.images[index].pageRangeStart = 1;
            states.images[index].pageRangeEnd = states.images[index].pageCount;
        }
    }
    
    // Update page range values
    function updatePageRange(index) {
        const startInput = document.getElementById(`range-start-${index}`);
        const endInput = document.getElementById(`range-end-${index}`);
        
        let start = parseInt(startInput.value);
        let end = parseInt(endInput.value);
        const maxPages = states.images[index].pageCount;
        
        // Validation
        if (start < 1) start = 1;
        if (start > maxPages) start = maxPages;
        if (end < start) end = start;
        if (end > maxPages) end = maxPages;
        
        // Update state
        states.images[index].pageRangeStart = start;
        states.images[index].pageRangeEnd = end;
        
        // Update inputs
        startInput.value = start;
        endInput.value = end;
    }
    
    // Rotate image (skip PDFs)
    window.rImg = (i, d) => {
        if (states.images[i].isPDF) {
            showToast('âš ï¸ PDFs cannot be rotated in this tool');
            return;
        }
        states.images[i].rot = (states.images[i].rot + d) % 360;
        renderImgList();
    };
    
    // Remove image with animation
    window.rmImg = i => {
        const fileName = states.images[i].file.name;
        
        // Find the row element
        const rows = document.querySelectorAll('.image-converter-row');
        const row = rows[i];
        
        if (row) {
            // Add removing class to trigger animation
            row.classList.add('removing');
            
            // Wait for animation to complete, then remove from array
            setTimeout(() => {
                states.images.splice(i, 1);
                renderImgList();
                showToast(`ğŸ—‘ï¸ Removed ${fileName}`);
            }, 300); // Match animation duration
        } else {
            // Fallback if element not found
            states.images.splice(i, 1);
            renderImgList();
            showToast(`ğŸ—‘ï¸ Removed ${fileName}`);
        }
    };
    
    // Apply "Convert All" quick selector
    function applyConvertAll() {
        const format = document.getElementById('convert-all-format').value;
        if(!format) return;
        
        states.images.forEach(img => {
            // IMPROVEMENT: Skip files that are already converted
            if(img.status !== 'done') {
                img.outputFormat = format;
            }
        });
        
        renderImgList();
        showToast(`âœ… All images set to ${format.toUpperCase()}`);
        
        // Reset the selector
        setTimeout(() => {
            document.getElementById('convert-all-format').value = '';
        }, 100);
    }
    
    // Update PDF merge checkbox visibility
    function updatePDFMergeVisibility() {
        const pdfCount = states.images.filter(img => img.outputFormat === 'pdf').length;
        const mergeContainer = document.getElementById('pdf-merge-container');
        
        if(pdfCount >= 2) {
            mergeContainer.style.display = 'block';
        } else {
            mergeContainer.style.display = 'none';
        }
    }
    
    // Convert single image with createImageBitmap optimization
    async function convertSingleImage(imageObj) {
        const { file, outputFormat, rot } = imageObj;
        
        try {
            // Warn for large files
            if(file.size > 20 * 1024 * 1024) {
                showToast('âš ï¸ Large image detected. Optimizing for stability...');
            }
            
            // CRITICAL: Use createImageBitmap for efficiency and safety
            const bitmap = await createImageBitmap(file, {
                resizeWidth: 3000,
                resizeHeight: 3000,
                resizeQuality: 'high'
            });
            
            // Apply 16MP safety cap
            const MAX_PIXELS = 16_000_000;
            let w = bitmap.width;
            let h = bitmap.height;
            
            if(w * h > MAX_PIXELS) {
                const ratio = Math.sqrt(MAX_PIXELS / (w * h));
                w = Math.floor(w * ratio);
                h = Math.floor(h * ratio);
            }
            
            // Create canvas
            const canvas = document.createElement('canvas');
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d', { alpha: outputFormat === 'png' });
            
            // Apply rotation
            if(rot !== 0) {
                ctx.translate(w/2, h/2);
                ctx.rotate(rot * Math.PI / 180);
                ctx.drawImage(bitmap, -w/2, -h/2, w, h);
            } else {
                ctx.drawImage(bitmap, 0, 0, w, h);
            }
            
            // Convert to blob
            let blob;
            if(outputFormat === 'pdf') {
                // For PDF, we'll create it later in the merge/bundle step
                // Just return canvas data for now
                blob = await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/jpeg', 0.85);
                });
            } else {
                const mimeType = `image/${outputFormat}`;
                const quality = outputFormat === 'jpg' ? 0.85 : outputFormat === 'webp' ? 0.80 : undefined;
                
                blob = await new Promise((resolve, reject) => {
                    canvas.toBlob(b => {
                        if(!b) reject(new Error('Conversion failed'));
                        else resolve(b);
                    }, mimeType, quality);
                });
            }
            
            // CRITICAL: Cleanup to prevent memory leaks
            bitmap.close();
            canvas.width = canvas.height = 0;
            
            return blob;
            
        } catch(error) {
            console.error('Conversion error:', error);
            throw error;
        }
    }
    
    // Convert all images
    async function convertAllImages() {
        // PROCESSING LOCK: Prevent double-clicks
        if (converterProcessing.isProcessing) {
            showToast('âš ï¸ Conversion already in progress');
            return;
        }
        
        // HYBRID APPROACH: Filter to only pending files
        const pendingImages = states.images.filter(img => img.status === 'pending');
        
        if(pendingImages.length === 0) {
            showToast('âš ï¸ No pending images to convert');
            return;
        }
        
        try {
            // SET PROCESSING STATE (use pending count, not total count)
            setConverterProcessing(true, 0, pendingImages.length);
            loading(true, 'Starting conversion...');
            
            // Reset errors
            converterProcessing.errors = [];
            
            // Remove pulse animation from button during conversion
            const convertBtn = document.querySelector('#img-action-bar .btn');
            if (convertBtn) convertBtn.classList.remove('has-pending-files');
            
            // Separate images by type and output format
            // Note: pdfImages = regular images being converted TO PDF
            //       pdfItems = actual PDF files being converted FROM PDF
            const pdfImages = pendingImages.filter(img => !img.isPDF && img.outputFormat === 'pdf');
            const otherImages = pendingImages.filter(img => !img.isPDF && img.outputFormat !== 'pdf');
            const mergePDFs = document.getElementById('merge-pdfs-checkbox').checked;
            
            let processedCount = 0;
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PROCESS PDF ITEMS FIRST (with page-range extraction)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const pdfItems = pendingImages.filter(img => img.isPDF);
            
            for (const item of pdfItems) {
                item.status = 'converting';
                renderImgList();
                
                setConverterProcessing(true, processedCount, pendingImages.length);
                
                try {
                    loading(true, `Extracting pages from ${item.file.name}...`);
                    
                    // Determine page range
                    const startPage = item.pageRangeMode === 'all' ? 1 : item.pageRangeStart;
                    const endPage = item.pageRangeMode === 'all' ? item.pageCount : item.pageRangeEnd;
                    const totalPages = endPage - startPage + 1;
                    
                    // Extract selected pages
                    const extractedImages = await extractPDFPageRange(
                        item.pdfDocument,
                        startPage,
                        endPage,
                        item.file.name,
                        item.outputFormat
                    );
                    
                    // Download as ZIP if multiple pages
                    if (extractedImages.length > 1) {
                        loading(true, `Creating ZIP file...`);
                        await downloadAsZIP(extractedImages, item.file.name.replace('.pdf', `_pages_${startPage}-${endPage}`));
                    } else {
                        // Single page - direct download
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(extractedImages[0].blob);
                        link.download = extractedImages[0].name;
                        link.click();
                        URL.revokeObjectURL(link.href);
                    }
                    
                    item.status = 'done';
                    item.convertedSize = extractedImages.reduce((sum, img) => sum + img.blob.size, 0);
                    
                } catch (error) {
                    item.status = 'error';
                    converterProcessing.errors.push({
                        filename: item.file.name,
                        reason: error.message || 'PDF extraction failed'
                    });
                    console.error('PDF extraction failed:', item.file.name, error);
                }
                
                processedCount++;
                renderImgList();
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PROCESS REGULAR IMAGES
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // Convert non-PDF images
            const regularImages = pendingImages.filter(img => !img.isPDF);
            
            for(let i = 0; i < regularImages.length; i++) {
                const img = regularImages[i];
                img.status = 'converting';
                renderImgList();
                
                // UPDATE GRANULAR PROGRESS
                setConverterProcessing(true, processedCount, pendingImages.length);
                
                try {
                    img.convertedBlob = await convertSingleImage(img);
                    img.convertedSize = img.convertedBlob.size;
                    img.status = 'done';
                } catch(error) {
                    img.status = 'error';
                    converterProcessing.errors.push({
                        filename: img.file.name,
                        reason: error.message || 'Conversion failed'
                    });
                    console.error('Conversion failed:', img.file.name, error);
                }
                
                processedCount++;
                renderImgList();
            }
            
            // Handle PDF images (regular images being converted TO PDF)
            if(pdfImages.length > 0) {
                if(mergePDFs && pdfImages.length > 1) {
                    // Create merged PDF
                    document.getElementById('loader-text').innerText = 'Merging PDFs...';
                    
                    const pdfDoc = await PDFDocument.create();
                    
                    for(let i = 0; i < pdfImages.length; i++) {
                        const img = pdfImages[i];
                        img.status = 'converting';
                        renderImgList();
                        
                        // UPDATE PROGRESS
                        setConverterProcessing(true, processedCount, states.images.length);
                        
                        try {
                            const blob = await convertSingleImage(img);
                            const arrayBuffer = await blob.arrayBuffer();
                            
                            // Embed image in PDF
                            const embeddedImage = await pdfDoc.embedJpg(arrayBuffer);
                            const page = pdfDoc.addPage([embeddedImage.width, embeddedImage.height]);
                            
                            page.drawImage(embeddedImage, {
                                x: 0,
                                y: 0,
                                width: embeddedImage.width,
                                height: embeddedImage.height
                            });
                            
                            if(img.rot !== 0) {
                                page.setRotation(degrees(img.rot));
                            }
                            
                            if(i === 0) {
                                img.status = 'done';
                            } else {
                                img.status = 'merged';
                            }
                        } catch(error) {
                            img.status = 'error';
                            converterProcessing.errors.push({
                                filename: img.file.name,
                                reason: error.message || 'PDF merge failed'
                            });
                            console.error('PDF conversion failed:', img.file.name, error);
                        }
                        
                        processedCount++;
                        renderImgList();
                    }
                    
                    const pdfBytes = await pdfDoc.save();
                    pdfImages[0].convertedBlob = new Blob([pdfBytes], { type: 'application/pdf' });
                    pdfImages[0].convertedSize = pdfBytes.length;
                    
                } else {
                    // Convert each to separate PDF
                    for(let i = 0; i < pdfImages.length; i++) {
                        const img = pdfImages[i];
                        img.status = 'converting';
                        renderImgList();
                        
                        // UPDATE PROGRESS
                        setConverterProcessing(true, processedCount, states.images.length);
                        
                        try {
                            const blob = await convertSingleImage(img);
                            const arrayBuffer = await blob.arrayBuffer();
                            
                            const pdfDoc = await PDFDocument.create();
                            const embeddedImage = await pdfDoc.embedJpg(arrayBuffer);
                            const page = pdfDoc.addPage([embeddedImage.width, embeddedImage.height]);
                            
                            page.drawImage(embeddedImage, {
                                x: 0,
                                y: 0,
                                width: embeddedImage.width,
                                height: embeddedImage.height
                            });
                            
                            if(img.rot !== 0) {
                                page.setRotation(degrees(img.rot));
                            }
                            
                            const pdfBytes = await pdfDoc.save();
                            img.convertedBlob = new Blob([pdfBytes], { type: 'application/pdf' });
                            img.convertedSize = pdfBytes.length;
                            img.status = 'done';
                        } catch(error) {
                            img.status = 'error';
                            converterProcessing.errors.push({
                                filename: img.file.name,
                                reason: error.message || 'PDF conversion failed'
                            });
                            console.error('PDF conversion failed:', img.file.name, error);
                        }
                        
                        processedCount++;
                        renderImgList();
                    }
                }
            }
            
            // HYBRID APPROACH: Smart UI state management
            updateConverterUIState();
            
            // Show/update results
            renderResults();
            
            // Show error summary if any errors occurred
            if (converterProcessing.errors.length > 0) {
                showErrorSummary();
            } else {
                showToast('âœ… Conversion complete!');
            }
            
        } catch(error) {
            console.error('Conversion error:', error);
            showToast('âŒ Conversion failed. Please try again.');
        } finally {
            // RELEASE PROCESSING LOCK
            setConverterProcessing(false);
            loading(false);
        }
    }
    
    // Show error summary after conversion
    function showErrorSummary() {
        const errorsDiv = document.createElement('div');
        errorsDiv.style.cssText = `
            background: rgba(239, 68, 68, 0.1);
            border: 2px solid var(--danger);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        `;
        
        const errorList = converterProcessing.errors.map(e => 
            `<li style="margin: 4px 0;"><strong>${e.filename}</strong> - ${e.reason}</li>`
        ).join('');
        
        errorsDiv.innerHTML = `
            <h4 style="margin: 0 0 12px 0; color: var(--danger); font-size: 1rem;">
                âš ï¸ ${converterProcessing.errors.length} file(s) failed to convert:
            </h4>
            <ul style="margin: 0; padding-left: 20px; color: var(--text-main);">
                ${errorList}
            </ul>
        `;
        
        document.getElementById('img-results').prepend(errorsDiv);
        
        const successCount = states.images.filter(img => img.status === 'done').length;
        showToast(`âš ï¸ ${successCount} converted, ${converterProcessing.errors.length} failed`);
    }
    
    // Render results section
    function renderResults() {
        const resultsList = document.getElementById('img-results-list');
        resultsList.innerHTML = '';
        
        const successImages = states.images.filter(img => img.status === 'done');
        
        // ITEM 4: Check if native sharing is supported
        const canShareFiles = navigator.share && navigator.canShare;
        
        successImages.forEach((img, idx) => {
            const resultRow = document.createElement('div');
            resultRow.style.cssText = `
                background: var(--bg-card);
                border: 2px solid var(--success);
                border-radius: 12px;
                padding: 16px;
                margin-bottom: 12px;
                display: flex;
                flex-direction: column;
                gap: 12px;
            `;
            
            const ext = img.outputFormat === 'jpg' ? 'jpg' : img.outputFormat === 'png' ? 'png' : img.outputFormat === 'webp' ? 'webp' : 'pdf';
            const originalMB = (img.originalSize / (1024*1024)).toFixed(2);
            const convertedMB = (img.convertedSize / (1024*1024)).toFixed(2);
            const savedPercent = Math.round((1 - img.convertedSize / img.originalSize) * 100);
            
            // ITEM 4: Share button HTML (only if supported)
            const shareBtn = canShareFiles ? `
                <button class="btn-outline" onclick="shareSingle(${idx})" style="flex: 1; margin: 0; border-color: var(--primary); color: var(--primary);">
                    ğŸ“¤ Share
                </button>
            ` : '';
            
            resultRow.innerHTML = `
                <div style="width: 100%; min-width: 0;">
                    <div style="font-weight: 600; margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                        ${img.file.name}
                    </div>
                    <div style="font-size: 0.85rem; color: var(--text-muted); display: flex; gap: 8px; flex-wrap: wrap;">
                        <span style="background: rgba(16, 185, 129, 0.1); color: #10b981; padding: 2px 8px; border-radius: 4px; font-weight: 600;">
                            ${ext.toUpperCase()}
                        </span>
                        <span>${originalMB}MB â†’ ${convertedMB}MB</span>
                        <span style="color: var(--success); font-weight: 600;">${savedPercent}% saved</span>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; width: 100%;">
                    ${shareBtn}
                    <button class="btn" onclick="downloadSingle(${idx})" style="flex: 1; margin: 0; padding: 10px;">
                        â¬‡ï¸ Save
                    </button>
                </div>
            `;
            
            resultsList.appendChild(resultRow);
        });
        
        // Update Download All button text
        const downloadAllBtn = document.getElementById('download-all-btn');
        if(successImages.length > 1) {
            downloadAllBtn.innerText = `ğŸ“¦ Download All (${successImages.length} files)`;
            downloadAllBtn.style.display = 'block';
        } else {
            downloadAllBtn.style.display = 'none';
        }
    }
    
    // ITEM 4: Share single converted file
    window.shareSingle = async function(index) {
        const successImages = states.images.filter(img => img.status === 'done');
        const img = successImages[index];
        
        if(!img || !img.convertedBlob) return;
        
        const ext = img.outputFormat === 'jpg' ? 'jpg' : img.outputFormat === 'png' ? 'png' : img.outputFormat === 'webp' ? 'webp' : 'pdf';
        const baseName = img.file.name.replace(/\.[^/.]+$/, '');
        const filename = `${baseName}.${ext}`;
        
        // Use shareFile function
        const shared = await shareFile(img.convertedBlob, filename);
        
        // If share failed or not supported, it already falls back to download
        if (!shared) {
            // Fallback already handled in shareFile function
        }
    };
    
    // Download single file
    window.downloadSingle = function(index) {
        const successImages = states.images.filter(img => img.status === 'done');
        const img = successImages[index];
        
        if(!img || !img.convertedBlob) return;
        
        const ext = img.outputFormat === 'jpg' ? 'jpg' : img.outputFormat === 'png' ? 'png' : img.outputFormat === 'webp' ? 'webp' : 'pdf';
        const baseName = img.file.name.replace(/\.[^/.]+$/, '');
        const filename = `${baseName}.${ext}`;
        
        download(img.convertedBlob, filename);
    };
    
    // Download all files as ZIP
    async function downloadAllResults() {
        const successImages = states.images.filter(img => img.status === 'done');
        
        if(successImages.length === 0) {
            showToast('âš ï¸ No files to download');
            return;
        }
        
        if(successImages.length === 1) {
            downloadSingle(0);
            return;
        }
        
        try {
            loading(true, 'Creating ZIP file...');
            
            const zip = new JSZip();
            
            successImages.forEach(img => {
                const ext = img.outputFormat === 'jpg' ? 'jpg' : img.outputFormat === 'png' ? 'png' : img.outputFormat === 'webp' ? 'webp' : 'pdf';
                const baseName = img.file.name.replace(/\.[^/.]+$/, '');
                const filename = `${baseName}.${ext}`;
                
                zip.file(filename, img.convertedBlob);
            });
            
            const zipBlob = await zip.generateAsync({ type: 'blob' });
            download(zipBlob, 'converted-images.zip');
            
            showToast('âœ… ZIP downloaded successfully!');
            
        } catch(error) {
            console.error('ZIP creation error:', error);
            showToast('âŒ Failed to create ZIP file');
        } finally {
            loading(false);
        }
    }
    
    // Reset converter for new batch
    function resetImageConverter() {
        // PROCESSING LOCK: Prevent clearing during conversion
        if (converterProcessing.isProcessing) {
            showToast('âš ï¸ Please wait for conversion to complete');
            return;
        }
        
        states.images = [];
        converterProcessing.errors = [];
        document.getElementById('img-controls').style.display = 'none';
        document.getElementById('img-results').style.display = 'none';
        document.getElementById('img-action-bar').style.display = 'block';
        document.querySelector('#tool-images .upload-area').style.display = 'flex';
        renderImgList();
    }
    
    // Clear All with confirmation
    function clearAllImages() {
        // PROCESSING LOCK: Prevent clearing during conversion
        if (converterProcessing.isProcessing) {
            showToast('âš ï¸ Please wait for conversion to complete');
            return;
        }
        
        if (states.images.length === 0) return;
        
        // SAFETY GUARD: Confirmation dialog
        if (confirm(`Clear all ${states.images.length} images? This cannot be undone.`)) {
            states.images = [];
            converterProcessing.errors = [];
            resetImageConverter();
            showToast('ğŸ—‘ï¸ All images cleared');
        }
    }

    
    document.getElementById('in-numbers').addEventListener('change', async e => { 
        if(!e.target.files[0]) return; 
        files.numbers = e.target.files[0]; 
        
        document.querySelector('#tool-numbers .upload-area').style.display = 'none'; 
        document.getElementById('numbers-editor').style.display = 'block';
        
        // Render PDF preview
        await renderPdfPreview(files.numbers, 'numbers-grid');
    });
    async function addPageNumbers(){ loading(true); const pdf=await PDFDocument.load(await files.numbers.arrayBuffer()); const font=await pdf.embedFont(StandardFonts.Helvetica); const pos=document.getElementById('num-pos').value; const pages=pdf.getPages(); pages.forEach((p,i)=>{ const {width}=p.getSize(); const t=`Page ${i+1} of ${pages.length}`; const tw=font.widthOfTextAtSize(t,12); let x=20; if(pos==='bc')x=width/2-tw/2; if(pos==='br')x=width-tw-20; p.drawText(t,{x:x,y:20,size:12,font:font}); }); download(await pdf.save(),'numbered.pdf'); loading(false); }

    // Shared OCR handler
    async function handleOCRUpload(file) {
        if (!file) return;
        
        // Hide upload buttons, show editor
        document.querySelectorAll('#tool-ocr .upload-area').forEach(area => area.parentElement.style.display = 'none');
        document.getElementById('ocr-editor').style.display = 'block';
        document.getElementById('ocr-progress').innerText = "Preparing image...";
        
        // OPTIMIZED: Use createImageBitmap with orientation fix
        try {
            const bitmap = await createImageBitmap(file, {
                imageOrientation: 'from-image'  // Magic EXIF fix!
            });
            
            // Convert bitmap to blob for Tesseract
            const canvas = document.createElement('canvas');
            canvas.width = bitmap.width;
            canvas.height = bitmap.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(bitmap, 0, 0);
            bitmap.close();
            
            const blob = await new Promise(resolve => {
                canvas.toBlob(resolve, 'image/jpeg', 0.95);
            });
            
            const correctedFile = new File([blob], file.name, {
                type: 'image/jpeg',
                lastModified: Date.now()
            });
            
            document.getElementById('ocr-progress').innerText = "Initializing OCR...";
            
            // Run OCR on correctly-oriented image
            Tesseract.recognize(
                correctedFile,
                'eng',
                {
                    logger: m => {
                        document.getElementById('ocr-progress').innerText = `Status: ${m.status} (${Math.round(m.progress * 100)}%)`;
                    }
                }
            ).then(({ data: { text } }) => {
                document.getElementById('ocr-output').value = text;
                document.getElementById('ocr-progress').innerText = "Done!";
            });
        } catch (err) {
            console.error('OCR image processing error:', err);
            document.getElementById('ocr-progress').innerText = "Error processing image";
            showToast('âŒ Failed to process image', 3000);
        }
    }
    
    // Add event listeners for both OCR inputs
    document.getElementById('in-ocr-files').addEventListener('change', async e => {
        await handleOCRUpload(e.target.files[0]);
        e.target.value = '';
    });
    
    document.getElementById('in-ocr-camera').addEventListener('change', async e => {
        await handleOCRUpload(e.target.files[0]);
        e.target.value = '';
    });
    
    function copyOcr(){ navigator.clipboard.writeText(document.getElementById('ocr-output').value); showToast("Copied"); }
    
    // NEW: Handle OCR upload button click
    function handleOCRUploadClick() {
        // Check if mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
        
        if (isMobile) {
            // Mobile: Show modal with options
            openOCRModal();
        } else {
            // Desktop: Directly open file picker (no camera option)
            document.getElementById('in-ocr-files').click();
        }
    }
    
    // NEW: Open the OCR upload modal (mobile only)
    function openOCRModal() {
        const modal = document.getElementById('ocr-upload-modal');
        if (modal) {
            modal.style.display = 'flex';
            vibrate(HAPTIC.light);
        }
    }
    
    // NEW: Close the OCR upload modal
    function closeOCRModal() {
        const modal = document.getElementById('ocr-upload-modal');
        if (modal) {
            modal.style.display = 'none';
            vibrate(HAPTIC.light);
        }
    }
    
    // NEW: Select files from gallery (mobile)
    function selectOCRFiles() {
        closeOCRModal();
        setTimeout(() => {
            document.getElementById('in-ocr-files').click();
        }, 100);
    }
    
    // NEW: Take photo with camera (mobile)
    function selectOCRCamera() {
        closeOCRModal();
        setTimeout(() => {
            document.getElementById('in-ocr-camera').click();
        }, 100);
    }

    async function saveTextToPdf(){ const t=document.getElementById('text-pdf-input').value; if(!t)return alert("Empty"); loading(true); const pdf=await PDFDocument.create(); const p=pdf.addPage(); const {width,height}=p.getSize(); const f=await pdf.embedFont(StandardFonts.Helvetica); p.drawText(t,{x:50,y:height-50,size:12,font:f,maxWidth:width-100}); download(await pdf.save(),'notes.pdf'); loading(false); }

    document.getElementById('in-meta').addEventListener('change', async e => { 
        if(!e.target.files[0]) return; 
        
        files.meta = e.target.files[0]; 
        
        document.querySelector('#tool-metadata .upload-area').style.display = 'none'; 
        document.getElementById('meta-editor').style.display = 'block';
        
        // Load PDF and extract metadata
        const pdf = await PDFDocument.load(await files.meta.arrayBuffer()); 
        
        document.getElementById('meta-title').value = pdf.getTitle() || ''; 
        document.getElementById('meta-author').value = pdf.getAuthor() || '';
        
        // Show file info
        document.getElementById('meta-filename').innerText = files.meta.name;
        document.getElementById('meta-pages').innerText = pdf.getPageCount();
        document.getElementById('meta-size').innerText = (files.meta.size / 1024 / 1024).toFixed(2) + ' MB';
        
        // Render PDF preview
        await renderPdfPreview(files.meta, 'meta-grid');
    });
    async function saveMetadata(){ loading(true); const pdf=await PDFDocument.load(await files.meta.arrayBuffer()); pdf.setTitle(document.getElementById('meta-title').value); pdf.setAuthor(document.getElementById('meta-author').value); download(await pdf.save(),'meta.pdf'); loading(false); }

    // ========== COMPRESS PDF - DUAL MODE ==========
    let compressionMode = 'image'; // 'structure' or 'image'
    let imageQuality = 0.70; // 0.3 to 0.95 (legacy, will be replaced)
    
    // POWER COMBO: New state variables
    let compressionColorMode = 'color'; // 'color', 'grayscale', 'bw'
    let compressionQuality = 'balanced'; // 'email', 'balanced', 'high'
    
    // Update Color Mode selection
    function updateColorMode(mode) {
        compressionColorMode = mode;
        
        // Update UI - toggle selected state
        document.querySelectorAll('.color-mode-option').forEach(opt => {
            const isSelected = opt.dataset.mode === mode;
            opt.style.borderColor = isSelected ? 'var(--primary)' : 'var(--border)';
            opt.style.background = isSelected ? 'rgba(99, 102, 241, 0.05)' : 'transparent';
            
            if (isSelected) opt.classList.add('selected');
            else opt.classList.remove('selected');
        });
        
        // Update hint text
        const hints = {
            color: "ğŸ’¡ Keeps original colors - best for photos & graphics",
            grayscale: "ğŸ’¡ Best for documents & scans - saves ~30% more space",
            bw: "âš ï¸ Converts everything to black & white (including photos)<br>ğŸ’¡ Perfect for text-only documents - saves up to 95%"
        };
        
        document.getElementById('color-mode-hint').innerHTML = hints[mode];
    }
    
    // Update Compression Quality selection
    function updateCompressionQuality(quality) {
        compressionQuality = quality;
        
        // Update UI - toggle selected state
        document.querySelectorAll('.compression-preset').forEach(opt => {
            const isSelected = opt.dataset.quality === quality;
            opt.style.borderColor = isSelected ? 'var(--primary)' : 'var(--border)';
            opt.style.background = isSelected ? 'rgba(99, 102, 241, 0.05)' : 'transparent';
            
            if (isSelected) opt.classList.add('selected');
            else opt.classList.remove('selected');
        });
        
        // Update hint text
        const hints = {
            email: "ğŸ“§ Maximum compression - smallest file size for email",
            balanced: "ğŸ“Š Balanced compression - recommended for most PDFs",
            high: "ğŸ–¼ï¸ Minimal compression - preserves best visual quality"
        };
        
        document.getElementById('quality-hint').innerHTML = hints[quality];
    }
    
    // Get quality value from preset
    function getQualityValue(preset) {
        const qualities = {
            email: 0.3,
            balanced: 0.5,
            high: 0.8
        };
        return qualities[preset] || 0.5;
    }
    
    // Clear Compress PDF and reset to initial state
    function clearCompressPDF() {
        // PROCESSING LOCK: Prevent clearing during compression
        if (compressProcessing) {
            showToast('âš ï¸ Please wait for compression to complete');
            return;
        }
        
        // SAFETY GUARD: Confirmation dialog
        if (files.compress && confirm('Clear current PDF and start over?')) {
            files.compress = null;
            
            // Reset to initial state
            document.getElementById('compress-controls').style.display = 'none';
            document.getElementById('compress-results').style.display = 'none';
            document.querySelector('#tool-compress .upload-area').style.display = 'flex';
            
            // Reset file input
            document.getElementById('in-compress').value = '';
            
            // Reset to defaults
            compressionColorMode = 'color';
            compressionQuality = 'balanced';
            compressionMode = 'image';
            
            // Re-initialize UI (if user uploads again)
            updateColorMode('color');
            updateCompressionQuality('balanced');
            
            showToast('ğŸ—‘ï¸ PDF cleared - ready for new upload');
        }
    }
    
    document.getElementById('in-compress').addEventListener('change', async e => {
        if(!e.target.files[0]) return;
        
        files.compress = e.target.files[0];
        const fileSize = files.compress.size;
        const fileSizeMB = (fileSize / (1024 * 1024)).toFixed(2);
        
        // Show controls and enable all options
        document.getElementById('compress-controls').style.display = 'block';
        document.querySelector('#tool-compress .upload-area').style.display = 'none';
        
        // Hide previous results if any
        document.getElementById('compress-results').style.display = 'none';
        
        // Update file info
        document.getElementById('compress-filename').innerText = files.compress.name;
        document.getElementById('compress-original-size').innerText = fileSizeMB + ' MB';
        
        // Hide results if previously shown
        document.getElementById('compress-results').style.display = 'none';
        
        // Set initial mode display
        selectCompressionMode(compressionMode);
    });
    
    function selectCompressionMode(mode) {
        compressionMode = mode;
        
        // Update UI for mode selection
        document.querySelectorAll('.compression-mode').forEach(opt => {
            const isSelected = opt.dataset.mode === mode;
            opt.style.borderColor = isSelected ? 'var(--primary)' : 'var(--border)';
            opt.style.background = isSelected ? 'rgba(99, 102, 241, 0.05)' : 'transparent';
            
            const title = opt.querySelector('div:nth-child(1) div:nth-child(2)');
            if(title) title.style.color = isSelected ? 'var(--primary)' : 'var(--text-main)';
            
            if(isSelected) {
                opt.classList.add('selected');
            } else {
                opt.classList.remove('selected');
            }
        });
        
        // Show/hide controls based on mode
        const qualityControl = document.getElementById('image-quality-control');
        const structureInfo = document.getElementById('structure-info');
        
        if(mode === 'image') {
            qualityControl.style.display = 'block';
            structureInfo.style.display = 'none';
        } else {
            qualityControl.style.display = 'none';
            structureInfo.style.display = 'block';
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // COMPRESS PDF - PROCESSING LOCK
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let compressProcessing = false;
    
    async function compressPDF() {
        // PROCESSING LOCK
        if (compressProcessing) {
            showToast('âš ï¸ Compression already in progress');
            return;
        }
        
        if(!files.compress) {
            showToast('âš ï¸ Please select a PDF file first');
            return;
        }
        
        const originalSize = files.compress.size;
        
        try {
            compressProcessing = true;
            
            // Disable compress button
            const compressBtn = document.querySelector('#tool-compress .btn');
            if (compressBtn) {
                compressBtn.disabled = true;
                compressBtn.style.opacity = '0.5';
            }
            
            if(compressionMode === 'structure') {
                await compressPDFStructure(originalSize);
            } else {
                await compressPDFImages(originalSize);
            }
        } catch(error) {
            console.error('Compression error:', error);
            showToast('âŒ Error compressing PDF: ' + error.message);
        } finally {
            compressProcessing = false;
            loading(false);
            
            // Re-enable compress button
            const compressBtn = document.querySelector('#tool-compress .btn');
            if (compressBtn) {
                compressBtn.disabled = false;
                compressBtn.style.opacity = '1';
            }
        }
    }
    
    // MODE 1: Structure Optimization (Lossless)
    async function compressPDFStructure(originalSize) {
        loading(true, 'Optimizing PDF structure...');
        
        const arrayBuffer = await files.compress.arrayBuffer();
        const pdf = await PDFDocument.load(arrayBuffer);
        
        // Optimize structure
        const compressedBytes = await pdf.save({
            useObjectStreams: true,
            addDefaultPage: false,
            objectsPerTick: 100
        });
        
        const compressedSize = compressedBytes.byteLength;
        
        // Show results
        showCompressionResults(originalSize, compressedSize);
        
        // SHARE IMPLEMENTATION: Store compressed PDF and show action bar
        window.lastCompressedPDF = compressedBytes;
        showCompressActionBar();
    }
    
    // MODE 2: Image-Based Compression (Aggressive)
    async function compressPDFImages(originalSize) {
        loading(true, 'Starting compression...');
        
        const pdf = await pdfjsLib.getDocument(URL.createObjectURL(files.compress)).promise;
        const newPdf = await PDFDocument.create();
        const totalPages = pdf.numPages;
        
        // POWER COMBO: Get quality from preset
        const quality = getQualityValue(compressionQuality);
        
        // Calculate scale based on quality
        // Lower quality = also downscale for better compression
        let renderScale = 1.0;
        if(quality < 0.6) {
            renderScale = 0.75; // 75% size for very low quality
        } else if(quality < 0.75) {
            renderScale = 0.85; // 85% size for medium quality  
        }
        
        for(let i = 1; i <= totalPages; i++) {
            // OPTIMIZED: Update progress less frequently (every 5 pages or first/last)
            // This reduces UI redraws and speeds up compression
            if(i === 1 || i === totalPages || i % 5 === 0) {
                const progress = Math.round((i / totalPages) * 100);
                loading(true, `Compressing... ${progress}% (${i}/${totalPages} pages)`);
            }
            
            const page = await pdf.getPage(i);
            const originalViewport = page.getViewport({scale: 1.0});
            const viewport = page.getViewport({scale: renderScale});
            
            // Create canvas
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            
            // POWER COMBO: Apply color mode filter
            if (compressionColorMode === 'grayscale') {
                context.filter = 'grayscale(100%)';
            } else if (compressionColorMode === 'bw') {
                // Black & White: grayscale + high contrast + brightness adjustment
                context.filter = 'grayscale(100%) contrast(1.5) brightness(1.1)';
            }
            // else: color mode = no filter
            
            // Render PDF page to canvas (filter is applied automatically)
            await page.render({
                canvasContext: context,
                viewport: viewport
            }).promise;
            
            // Reset filter (good practice)
            context.filter = 'none';
            
            // Convert canvas to JPEG blob with quality setting
            const blob = await new Promise(resolve => {
                canvas.toBlob(resolve, 'image/jpeg', quality);
            });
            
            // Convert blob to array buffer
            const imageBytes = await blob.arrayBuffer();
            
            // Embed image in new PDF
            const image = await newPdf.embedJpg(imageBytes);
            
            // Add page with ORIGINAL dimensions (so page size stays same, image is just compressed)
            const newPage = newPdf.addPage([originalViewport.width, originalViewport.height]);
            newPage.drawImage(image, {
                x: 0,
                y: 0,
                width: originalViewport.width,
                height: originalViewport.height
            });
        }
        
        loading(true, 'Finalizing compressed PDF...');
        
        // Save the new PDF
        const compressedBytes = await newPdf.save();
        const compressedSize = compressedBytes.byteLength;
        
        // Show results
        showCompressionResults(originalSize, compressedSize);
        
        // SHARE IMPLEMENTATION: Store compressed PDF and show action bar
        window.lastCompressedPDF = compressedBytes;
        showCompressActionBar();
    }
    
    // SHARE IMPLEMENTATION: Compress PDF share and download functions
    async function shareCompressedPDF() {
        if (!window.lastCompressedPDF) {
            showToast('âŒ No compressed PDF available');
            return;
        }
        
        const blob = new Blob([window.lastCompressedPDF], {type: 'application/pdf'});
        const filename = 'compressed_' + (files.compress ? files.compress.name : 'document.pdf');
        const shared = await shareFile(blob, filename);
        
        if (shared) {
            vibrate(HAPTIC.success);
        }
    }
    
    function downloadCompressedPDF() {
        if (!window.lastCompressedPDF) {
            showToast('âŒ No compressed PDF available');
            return;
        }
        
        const filename = 'compressed_' + (files.compress ? files.compress.name : 'document.pdf');
        download(window.lastCompressedPDF, filename);
        vibrate(HAPTIC.success);
    }
    
    function showCompressActionBar() {
        const actionBar = document.getElementById('compress-action-bar');
        if (actionBar) {
            actionBar.style.display = 'flex';
        }
    }
    
    function hideCompressActionBar() {
        const actionBar = document.getElementById('compress-action-bar');
        if (actionBar) {
            actionBar.style.display = 'none';
        }
        window.lastCompressedPDF = null;
    }
    
    function showCompressionResults(originalSize, compressedSize) {
        // Calculate savings
        const savedBytes = originalSize - compressedSize;
        const savedPercent = ((savedBytes / originalSize) * 100).toFixed(1);
        
        const originalMB = (originalSize / (1024 * 1024)).toFixed(2);
        const compressedMB = (compressedSize / (1024 * 1024)).toFixed(2);
        const savedMB = (savedBytes / (1024 * 1024)).toFixed(2);
        
        // Show results
        document.getElementById('result-original-size').innerText = originalMB + ' MB';
        document.getElementById('result-compressed-size').innerText = compressedMB + ' MB';
        document.getElementById('result-saved-size').innerText = savedMB + ' MB';
        document.getElementById('result-saved-percent').innerText = savedPercent;
        
        // Smart analysis - determine outcome quality
        let analysisMessage = '';
        let analysisColor = '#10b981'; // Green by default
        let showWarning = false;
        
        // Reset results card to default green style
        document.getElementById('compress-results').style.background = 'linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(5, 150, 105, 0.05) 100%)';
        document.getElementById('compress-results').style.borderColor = '#10b981';
        document.querySelector('#compress-results h3').style.color = '#10b981';
        document.querySelector('#compress-results h3').innerHTML = 'Compression Complete!';
        
        if(compressedSize >= originalSize) {
            // File got bigger - BAD
            analysisMessage = 'âš ï¸ <strong>Compression increased file size!</strong><br>Your PDF is already well-optimized. The original file is smaller. We recommend keeping the original.';
            analysisColor = '#ef4444'; // Red
            showWarning = true;
            
            // Change result card to warning style
            document.getElementById('compress-results').style.background = 'linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(220, 38, 38, 0.05) 100%)';
            document.getElementById('compress-results').style.borderColor = '#ef4444';
            document.querySelector('#compress-results h3').style.color = '#ef4444';
            document.querySelector('#compress-results h3').innerHTML = 'âš ï¸ Compression Not Effective';
            
        } else if(savedPercent < 1) {
            // Less than 1% savings - MINIMAL
            analysisMessage = 'â„¹ï¸ <strong>Minimal compression achieved.</strong><br>Your PDF is already well-optimized. Only ' + savedPercent + '% reduction is possible without quality loss.';
            analysisColor = '#f59e0b'; // Orange
            showWarning = true;
            
            // Change to info style
            document.getElementById('compress-results').style.background = 'linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(217, 119, 6, 0.05) 100%)';
            document.getElementById('compress-results').style.borderColor = '#f59e0b';
            document.querySelector('#compress-results h3').style.color = '#f59e0b';
            document.querySelector('#compress-results h3').innerHTML = 'â„¹ï¸ Already Optimized';
            
        } else if(savedPercent < 5) {
            // Less than 5% savings - LOW
            analysisMessage = 'ğŸ’¡ <strong>Low compression achieved.</strong><br>Saved ' + savedPercent + '%. Your PDF is already fairly optimized. For better results, try the other compression mode or use lower quality settings.';
            analysisColor = '#f59e0b'; // Orange
            
        } else if(savedPercent < 20) {
            // 5-20% savings - GOOD
            analysisMessage = 'âœ… <strong>Good compression!</strong><br>Saved ' + savedPercent + '% (' + savedMB + ' MB) while maintaining quality.';
            analysisColor = '#10b981'; // Green
            
        } else {
            // 20%+ savings - EXCELLENT
            analysisMessage = 'ğŸ‰ <strong>Excellent compression!</strong><br>Saved ' + savedPercent + '% (' + savedMB + ' MB). Significant file size reduction achieved!';
            analysisColor = '#10b981'; // Green
        }
        
        // Add analysis message to results
        const existingAnalysis = document.getElementById('compression-analysis');
        if(existingAnalysis) existingAnalysis.remove();
        
        const analysisDiv = document.createElement('div');
        analysisDiv.id = 'compression-analysis';
        analysisDiv.style.cssText = `
            margin-top: 16px;
            padding: 14px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            border: 1px solid ${analysisColor};
        `;
        analysisDiv.innerHTML = `
            <p style="margin: 0; font-size: 0.9rem; color: var(--text-main); line-height: 1.5;">
                ${analysisMessage}
            </p>
        `;
        
        document.getElementById('compress-results').appendChild(analysisDiv);
        
        // Show recommendation for mode switching if current mode didn't work well
        if(showWarning && savedPercent < 5) {
            const currentMode = compressionMode;
            const suggestedMode = currentMode === 'structure' ? 'Compress Images' : 'Optimize Structure';
            
            const recommendDiv = document.createElement('div');
            recommendDiv.style.cssText = `
                margin-top: 12px;
                padding: 12px;
                background: rgba(99, 102, 241, 0.05);
                border-radius: 8px;
                border: 1px solid var(--primary);
            `;
            recommendDiv.innerHTML = `
                <p style="margin: 0; font-size: 0.85rem; color: var(--text-secondary); line-height: 1.5;">
                    ğŸ’¡ <strong>Tip:</strong> Try "${suggestedMode}" mode for potentially better results.
                </p>
            `;
            
            document.getElementById('compress-results').appendChild(recommendDiv);
        }
        
        document.getElementById('compress-results').style.display = 'block';
        
        // Conditional toast message
        if(compressedSize >= originalSize) {
            showToast('âš ï¸ File got bigger - keep original!');
        } else if(savedPercent < 1) {
            showToast(`â„¹ï¸ Already optimized (${savedPercent}%)`);
        } else {
            showToast(`âœ… Saved ${savedMB} MB (${savedPercent}%)`);
        }
    }


    // FIX: Enhanced download function with proper MIME type detection
    function download(d, n) {
        // Detect MIME type from filename extension
        let mimeType;
        
        if (n.endsWith('.zip')) {
            mimeType = 'application/zip';
        } else if (n.endsWith('.jpg') || n.endsWith('.jpeg')) {
            mimeType = 'image/jpeg';
        } else if (n.endsWith('.png')) {
            mimeType = 'image/png';
        } else if (n.endsWith('.webp')) {
            mimeType = 'image/webp';
        } else if (n.endsWith('.pdf')) {
            mimeType = 'application/pdf';
        } else if (n.endsWith('.txt')) {
            mimeType = 'text/plain';
        } else {
            // Fallback: try to detect from blob if available, or use generic binary
            mimeType = d.type || 'application/octet-stream';
        }
        
        const a = document.createElement('a');
        const blobUrl = URL.createObjectURL(new Blob([d], { type: mimeType }));
        a.href = blobUrl;
        a.download = n;
        a.click();
        
        // Memory cleanup - revoke the object URL after a short delay
        setTimeout(() => URL.revokeObjectURL(blobUrl), 100);
        
        showToast("Downloaded");
    }
    
    // ================== PHASE 3: PWA SUPPORT ==================
    // Single-file PWA implementation (no separate sw.js or manifest.json files)
    
    // PWA: Manual Install Trigger
    let deferredInstallPrompt;
    
    window.addEventListener('beforeinstallprompt', (e) => {
        // Prevent mini-infobar on mobile
        e.preventDefault();
        
        // Save the event for later
        deferredInstallPrompt = e;
        
        // Add pulsing animation to indicate install is ready
        const installBtn = document.getElementById('pwa-install-btn');
        if (installBtn) {
            installBtn.style.animation = 'gentlePulse 2s ease-in-out infinite';
            installBtn.title = 'Install App (Ready!)';
        }
    });
    
    // Function to trigger PWA install
    async function installPWA() {
        // Detect if running in embedded browser (Telegram, Facebook, Instagram, etc.)
        const isEmbedded = /FBAN|FBAV|Instagram|TelegramBot|Telegram|Line|WeChat|QQ/.test(navigator.userAgent);
        const isStandalone = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;
        
        // Already installed
        if (isStandalone) {
            showToast('âœ… App is already installed!', 3000);
            const installBtn = document.getElementById('pwa-install-btn');
            if (installBtn) installBtn.style.display = 'none';
            return;
        }
        
        // Running in embedded browser (Telegram, etc.)
        if (isEmbedded) {
            showToast('ğŸŒ Please open in your browser (Chrome/Safari) to install the app', 5000);
            setTimeout(() => {
                showToast('ğŸ’¡ Tap the "â‹®" menu â†’ "Open in browser"', 4000);
            }, 5500);
            return;
        }
        
        // Check if prompt is available
        if (!deferredInstallPrompt) {
            // Provide browser-specific installation instructions
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const isAndroid = /Android/.test(navigator.userAgent);
            const isChrome = /Chrome/.test(navigator.userAgent) && !/Edge/.test(navigator.userAgent);
            
            if (isIOS) {
                showToast('ğŸ“± iOS: Tap Share button â†’ "Add to Home Screen"', 5000);
            } else if (isAndroid && isChrome) {
                showToast('ğŸ“± Tap browser menu (â‹®) â†’ "Install app"', 5000);
            } else if (isChrome) {
                showToast('ğŸ’» Look for install icon (âŠ•) in address bar', 4000);
            } else {
                showToast('â„¹ï¸ Check browser menu for "Install" option', 4000);
            }
            return;
        }
        
        try {
            // Show install prompt
            deferredInstallPrompt.prompt();
            
            // Wait for user choice
            const { outcome } = await deferredInstallPrompt.userChoice;
            
            if (outcome === 'accepted') {
                showToast('ğŸ‰ App installed! Check your home screen.', 3000);
                vibrate(HAPTIC.success);
                
                // Hide install button after successful install
                const installBtn = document.getElementById('pwa-install-btn');
                if (installBtn) installBtn.style.display = 'none';
            } else {
                showToast('â„¹ï¸ You can install later from browser menu.', 3000);
            }
            
            // Clear the prompt
            deferredInstallPrompt = null;
        } catch (err) {
            console.error('PWA install error:', err);
            showToast('âŒ Installation failed. Try from browser menu.', 3000);
        }
    }
    
    // Detect successful installation
    window.addEventListener('appinstalled', () => {
        showToast('âœ… App installed successfully!', 3000);
        vibrate(HAPTIC.success);
        
        const installBtn = document.getElementById('pwa-install-btn');
        if (installBtn) installBtn.style.display = 'none';
    });
    
    // ================== AUTO-UPDATE DETECTION ==================
    // Check for updates and notify user
    
    async function checkForUpdates() {
        try {
            // Fetch the latest version of index.html
            const response = await fetch(window.location.href, {
                cache: 'no-store',
                headers: { 'Cache-Control': 'no-cache' }
            });
            
            if (!response.ok) return;
            // Extract version from the fetched HTML
			const html = await response.text();
            const match = html.match(/const CACHE_NAME = '([^']+)'/);
            if (!match) return;
			
			const latestVersion = match[1];
            const storedVersion = localStorage.getItem('app_version');


            // First run â†’ save version
            if (!storedVersion) {
                localStorage.setItem('app_version', latestVersion);
                return;
            } 
			const pendingUpdate = localStorage.getItem('pending_update');
			// Show toast ONLY if version changed
			if (latestVersion !== storedVersion && pendingUpdate !== latestVersion) {
			    localStorage.setItem('pending_update', latestVersion);
			    showUpdateNotification(latestVersion);
			}         
        } catch (error) {
            console.log('Update check failed:', error);
        }
    }
    
    function showUpdateNotification(newVersion) {
        // Check if notification already exists
        if (document.getElementById('update-notification')) return;
        
        const notification = document.createElement('div');
        notification.id = 'update-notification';
        notification.className = 'update-notification';
        notification.innerHTML = `
            <span style="font-size: 24px;">ğŸ‰</span>
            <div>
                <div style="font-size: 15px;">New update available!</div>
                <div style="font-size: 13px; opacity: 0.9;">Tap to reload and update</div>
            </div>
        `;
        
        notification.onclick = () => {
            // âœ… Mark this version as accepted
			localStorage.setItem('app_version', newVersion);
			localStorage.removeItem('pending_update');
            // Show loading toast
            showToast('â³ Updating...', 1000);
			
			setTimeout(() => {
			    location.reload(true);
			}, 800);
            
        };
        
        document.body.appendChild(notification);
        vibrate(HAPTIC.light);
    }
    
    // Check for updates when app loads
    if (window.location.protocol !== 'file:') {
        // Initial check after 3 seconds
        setTimeout(checkForUpdates, 3000);
        
        // Periodic check every 5 minutes
        setInterval(checkForUpdates, 5 * 60 * 1000);
        
        // Check when app becomes visible (user switches back to tab/app)
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                checkForUpdates();
            }
        });
    }
    
    
    // PWA: Register Service Worker (Inline Approach)
    if ('serviceWorker' in navigator && window.location.protocol !== 'file:') {
        window.addEventListener('load', () => {
            const swCode = `
                const CACHE_NAME = 'pdf-toolkit-v2';
                
                self.addEventListener('install', (event) => {
                    event.waitUntil(
                        caches.open(CACHE_NAME).then((cache) => {
                            return cache.add(new Request(self.registration.scope));
                        })
                    );
                    self.skipWaiting();
                });
                
                self.addEventListener('activate', (event) => {
                    event.waitUntil(
                        caches.keys().then((cacheNames) => {
                            return Promise.all(
                                cacheNames.map((cacheName) => {
                                    if (cacheName !== CACHE_NAME) {
                                        return caches.delete(cacheName);
                                    }
                                })
                            );
                        })
                    );
                    self.clients.claim();
                });
                
                self.addEventListener('fetch', (event) => {
                    event.respondWith(
                        caches.match(event.request).then((response) => {
                            return response || fetch(event.request);
                        })
                    );
                });
            `;
            
            const blob = new Blob([swCode], { type: 'application/javascript' });
            const swURL = URL.createObjectURL(blob);
            
            navigator.serviceWorker.register(swURL)
                .then((registration) => {
                    console.log('âœ… PWA: Service Worker registered');
                })
                .catch((error) => {
                    console.log('â„¹ï¸ PWA: Service Worker not registered:', error.message);
                });
        });
    } else if (window.location.protocol === 'file:') {
        console.log('â„¹ï¸ PWA: Offline mode requires http:// or https://');
    }
</script>
</body>
</html>